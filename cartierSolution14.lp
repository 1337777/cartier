// require open Blanqui.Lib.Set Blanqui.Lib.Prop Blanqui.Lib.FOL Blanqui.Lib.Eq Blanqui.Lib.Bool Blanqui.Lib.Nat Blanqui.Lib.List;
require open modos.cartierSolution13;

// flag "eta_equality" on; // default is off
// flag "print_contexts" on; // default is off
// flag "print_domains" on; // default is off
// flag "print_meta_types" on; // default is off

inductive one : TYPE ‚âî One : one;
constant symbol one_Set : Set;
rule œÑ one_Set ‚Ü™ one;
  
constant symbol obj : Œ† C : cat, TYPE;
constant symbol obj_Set : Œ† C : cat, Set;
rule œÑ (obj_Set $C) ‚Ü™ obj $C;

symbol ‚àò>o: Œ† [Y Z : cat], obj Y ‚Üí func Y Z ‚Üí obj Z;
notation ‚àò>o infix left 90;

rule $X ‚àò>o ($G ‚àò> $H) ‚Ü™ ($X ‚àò>o $G) ‚àò>o $H
with $F ‚àò>o Id_func ‚Ü™ $F;

///TODO also dependent versions of One elim, and dependent One
//Terminal_cat ahas dual status as also datatype: 
//intro rule
constant symbol Terminal_obj : obj Terminal_cat; 
//elim rule, rename Terminal_elim_func ?
injective symbol Obj_func : Œ† [Y : cat], obj Y ‚Üí func Terminal_cat Y ;

//computation rule, obj
//  rule (Terminal_obj) ‚àò>o (Obj_func $F) ‚Ü™  $F;
rule $M ‚àò>o (Obj_func $F) ‚Ü™  $F;

//TODO reverse also Terminal_elim_funcd... same as ordinarry cut-elim with functors
rule (Obj_func $F) ‚àò> $H ‚Ü™ (Obj_func ($F ‚àò>o $H));

injective symbol Op_obj : Œ† [ Y : cat] , obj Y ‚Üí obj (Op_cat Y);
rule Op_obj ($F ‚àò>o $G) ‚Ü™ (Op_obj $F) ‚àò>o (Op_func $G); //or reverse?
rule Obj_func (Terminal_obj) ‚Ü™ Id_func; //as usual this causes non-constant symbol

constant symbol arr: Œ† [A B : cat], obj A ‚Üí mod A B ‚Üí obj B ‚Üí  TYPE ;
constant symbol arr_Set: Œ† [A B : cat], obj A ‚Üí mod A B ‚Üí obj B ‚Üí Set ;
rule œÑ (@arr_Set $A $B $F $R $G) ‚Ü™ (@arr $A $B $F $R $G);

//todo erase Id condition?
symbol '‚àòa : Œ† [A B' B : cat] [S : mod A B'] [T : mod A B]
[X : obj A] [Y : obj B']  [G : func B' B], //SHOULD X be Terminal_obj ?
arr X S Y ‚Üí transf S Id_func T G ‚Üí arr X T (Y ‚àò>o G);
notation '‚àòa infix right 80;
symbol ‚àòa' [A' B A : cat] [S : mod A' B] [T : mod A B]
[X : obj A'] [Y : obj B] [F : func A' A] : //SHOULD Y be Terminal_obj ?
transf S F T Id_func ‚Üí arr X S Y ‚Üí arr (X ‚àò>o F) T Y;
notation ‚àòa' infix left 80;

//todo both cov ad con of ''‚àò (nahhh erase: only operator arrgument has Id frame)?
rule ($r '‚àòa $rs) '‚àòa $st
‚Ü™  $r '‚àòa ($rs ''‚àò $st);
rule $r '‚àòa (Id_transf _) ‚Ü™ $r;
rule $st ‚àòa' ($rs ‚àòa' $r)
‚Ü™  ($st ‚àò'' $rs) ‚àòa' $r;
rule (Id_transf _) ‚àòa' $r ‚Ü™ $r;

/// aka terminalunitprofunctor_elim_hom, which, for one, contains also terminal_elim_cov_hom
//TODO redo
//  injective symbol Arr_hom: Œ† [A B : cat] [F : obj A] [R : mod A B] [G : obj B],  arr F R G ‚Üí hom (Obj_func F) R (Obj_func G);
injective symbol Arr_hom /* terminalunitprofunctor_elim_hom */: 
Œ† [A B: cat] [R : mod A B]  (F : func Terminal_cat A) (G : func Terminal_cat B) 
(t_arr : arr (Terminal_obj ‚àò>o F) R (Terminal_obj ‚àò>o G)),
hom F R G;

symbol DEFINABLE_Arr_hom_instance_terminal_elim_cov_hom  [E  : cat] (F : func Terminal_cat E)  (G : func Terminal_cat E)
(t_arr : arr (Terminal_obj ‚àò>o F) (Unit_mod Id_func (G )) Terminal_obj) : //TODO  o<‚àò
  hom F (Unit_mod Id_func G) Id_func ‚âî Arr_hom _ _ t_arr ;

//computation rule for Arr_hom
//reversed to tradeoff with more usual rule for datatype elimination... nope reversed back because elim now uses arr input
rule (Arr_hom _ _ $r) '‚àò $t  ‚Ü™ (Arr_hom _ _ ($r '‚àòa $t));
rule  $t ‚àò' (Arr_hom _ _ $r)  ‚Ü™ (Arr_hom _ _ ($t ‚àòa' $r));

//TODO? Id_arr ?
// constant symbol Id_arr [A : cat] (F : obj A)  : arr F (Unit_mod Id_func Id_func) F;
// rule (Id_arr Terminal_obj) '‚àòa ( (_) _'‚àò> (Arr_hom $r)) ‚Ü™  $r;
// rule Arr_hom (Id_arr $F) ‚Ü™ Id_hom (Obj_func $F);

//TODO rename Func_cov_hom to Id_cov_hom because of this explanation: ?
constant symbol Id_cov_arr [A : cat] (F : obj A)  : arr F (Unit_mod Id_func (Obj_func F)) Terminal_obj;
//computation rule for Arr_hom
rule (Id_cov_arr $F) '‚àòa ( (_) _'‚àò> (Arr_hom _ _ $r)) ‚Ü™  $r;
rule Arr_hom (Obj_func _) Id_func (Id_cov_arr $F) ‚Ü™ Func_cov_hom _ _ ;

constant symbol Id_con_arr [A : cat] (F : obj A)  : arr Terminal_obj (Unit_mod (Obj_func F) Id_func ) F;
rule ( (Arr_hom _ _ $r) ‚àò>'_ (_)) ‚àòa' (Id_con_arr $F)   ‚Ü™  $r;
rule Arr_hom Id_func (Obj_func _) (Id_con_arr $F) ‚Ü™ Func_con_hom _ _ ;

//computation rule for Obj_func, arr
rule (Func_cov_hom ( Obj_func $E_obj) _) ‚àò>'_(_) ‚àòa' (Id_cov_arr $M)
  ‚Ü™ (Id_cov_arr $E_obj);



//TODO REVIEW ‚àò‚Üìo and Func_con_arr not necessary  ?
// TODO  ‚àò‚Üìo ?  vs (Func_cov_arr $F) '‚àòa  (_) _'‚àò>
symbol ‚àò‚Üìo : Œ† [I A B : cat] [R : mod A B] [F : func I A] 
[G : func I B], hom F R G ‚Üí Œ† (X : obj I), arr (X ‚àò>o F) R (X ‚àò>o G);
notation ‚àò‚Üìo infix left 120;

//TODO ?
rule (Arr_hom _ _ $r) ‚àò‚Üìo Terminal_obj  ‚Ü™  $r;

//reverse direction?
rule ($r ‚àò‚Üì $H) ‚àò‚Üìo $K ‚Ü™ $r ‚àò‚Üìo ($K ‚àò>o $H  );

///TODO ?
constant symbol Func_con_arr : Œ† [I J] (Z: func I J ) (M: obj I),
  arr M (Unit_mod Z Id_func) (M ‚àò>o Z);
  type Œª [A : cat] (F : obj A), Func_con_arr (Obj_func F) Terminal_obj;
constant symbol Func_cov_arr : Œ† [I J] (Z: func I J ) (M: obj I),
  arr (M ‚àò>o Z) (Unit_mod Id_func Z) M;
rule  (Func_con_hom $Z $F) ‚àò‚Üìo $H  ‚Ü™ Func_con_arr $Z ($H ‚àò>o $F)
with (Func_cov_hom $Z $F) ‚àò‚Üìo $H  ‚Ü™ Func_cov_arr $Z ($H ‚àò>o $F); 


//TODO MEMO LATER... get complex
constant symbol presh : Œ† C : cat, TYPE;
constant symbol presh_Set : Œ† C : cat, Set;
rule œÑ (presh_Set $C) ‚Ü™ presh $C;
constant symbol copresh : Œ† C : cat, TYPE;
constant symbol copresh_Set : Œ† C : cat, Set;
rule œÑ (copresh_Set $C) ‚Ü™ copresh $C;
constant symbol ‚äóo : Œ† [A B : cat], mod A B ‚Üí presh B ‚Üí presh A ; //Tensor_mod;
notation ‚äóo infix left 70;
constant symbol o‚äó : Œ† [A B: cat], copresh A ‚Üí mod A B ‚Üí  copresh B ; //Tensor_mod;
notation o‚äó infix left 70;
constant symbol Unit_presh : Œ† [X A  : cat], func A X ‚Üí obj X ‚Üí  presh A ;
symbol o<<‚àò : Œ† [A X : cat], mod A X ‚Üí obj X ‚Üí presh A;
symbol ‚àò>>o : Œ† [B X: cat], obj X ‚Üí mod X B ‚Üí copresh B;
notation o<<‚àò infix left 80; notation ‚àò>>o infix right 80;
rule  (Unit_mod $F $G) o<<‚àò $K ‚Ü™ Unit_presh $F ($K ‚àò>o $G) 
with ($R ‚äó $S) o<<‚àò $G ‚Ü™ $R ‚äóo ($S o<<‚àò $G);
injective symbol Presh_mod : Œ† [Y : cat], presh Y ‚Üí mod Y Terminal_cat ;
rule (Presh_mod $F) o<<‚àò $M ‚Ü™ $F;



 ////-----------

inductive category : TYPE ‚âî | Struct_category : Œ† 
(category_Obj : Set) 
(category_Arr : œÑ category_Obj ‚Üí œÑ category_Obj ‚Üí Set)
(category_Comp : Œ† [M N L : œÑ category_Obj] (f : œÑ (category_Arr M N)) (g : œÑ (category_Arr N L)), œÑ (category_Arr M L)) 
(category_Iden : Œ† (M: œÑ category_Obj), œÑ (category_Arr M M)), category;

injective symbol category_Obj_Set (C : category) : Set;
rule category_Obj_Set (Struct_category $category_Obj $category_Arr $category_Comp $category_Iden) ‚Ü™ $category_Obj;
injective symbol category_Obj (C : category) : TYPE ‚âî œÑ (category_Obj_Set C);
injective symbol category_Arr_Set [C : category]  : (category_Obj C) ‚Üí (category_Obj C) ‚Üí Set;
rule @category_Arr_Set (Struct_category $category_Obj $category_Arr $category_Comp $category_Iden) ‚Ü™ $category_Arr;
injective symbol category_Arr [C : category]  : (category_Obj C) ‚Üí (category_Obj C) ‚Üí TYPE ‚âî Œª M N, œÑ (category_Arr_Set M N);
symbol category_Comp [C : category] : Œ† [M N L : (category_Obj C)] (f : category_Arr M N) (g : (category_Arr N L)), (category_Arr M L);
rule @category_Comp (Struct_category $category_Obj $category_Arr $category_Comp $category_Iden) ‚Ü™ $category_Comp;
symbol category_Iden [C : category] : Œ† (M:  (category_Obj C)), (category_Arr M M);
rule @category_Iden (Struct_category $category_Obj $category_Arr $category_Comp $category_Iden) ‚Ü™ $category_Iden;

(C D : category) inductive functor : TYPE ‚âî | Struct_functor : Œ† 
(functor_Obj : category_Obj C ‚Üí category_Obj D) 
(functor_Arr : Œ† [M N : category_Obj C], category_Arr M N ‚Üí category_Arr (functor_Obj M) (functor_Obj N)), functor C D;

symbol functor_Obj [C D : category] (F : functor C D) :  category_Obj C ‚Üí category_Obj D;
rule functor_Obj (Struct_functor $functor_Obj $functor_Arr) ‚Ü™ $functor_Obj;
symbol functor_Arr [C D : category] (F : functor C D) :  Œ† [M N : category_Obj C], category_Arr M N ‚Üí category_Arr (functor_Obj F M) (functor_Obj F N);
rule @functor_Arr _ _ (Struct_functor $functor_Obj $functor_Arr) ‚Ü™ $functor_Arr;

symbol comp_functor [C D E : category] (F : functor C D) (G : functor D E) : functor C E
 ‚âî Struct_functor (Œª M : category_Obj C, functor_Obj G (functor_Obj F M)) (Œª (M N : category_Obj C) a, (functor_Arr G (functor_Arr F a)));
symbol iden_functor (C : category) : functor C C
 ‚âî Struct_functor (Œª M : category_Obj C, M) (Œª (M N : category_Obj C) a, a);

symbol constant_functor (C : category) [D : category] (M : category_Obj D) : functor C D
‚âî Struct_functor (Œª _, M) (Œª _ _ _, category_Iden M);


[C D : category] inductive transformation (F G: functor C D) : TYPE ‚âî | Struct_transformation [F G: functor C D] : Œ† 
(transformation_Arr : Œ† (M : category_Obj C), category_Arr (functor_Obj F M) (functor_Obj G M)), transformation F G;

symbol transformation_Arr [C D : category] [F G: functor C D]  (h : transformation F G) : Œ† (M : category_Obj C), category_Arr (functor_Obj F M) (functor_Obj G M);
rule transformation_Arr (Struct_transformation $transformation_Arr) ‚Ü™ $transformation_Arr;

symbol iden_transformation [C D : category] (F : functor C D) : transformation F F 
 ‚âî Struct_transformation (Œª M : category_Obj C, category_Iden (functor_Obj F M));
symbol comp_transformation [C D : category] [F G H: functor C D] (h : transformation F G) (t : transformation G H) : transformation F H 
 ‚âî Struct_transformation (Œª M : category_Obj C, category_Comp (transformation_Arr h M) (transformation_Arr t M));
symbol tensor_cov_transformation [C D E : category] [F G : functor C D] (h : transformation F G) (K : functor D E) : transformation (comp_functor F K) (comp_functor G K)
 ‚âî Struct_transformation (Œª M : category_Obj C, functor_Arr K (transformation_Arr h M));
 symbol tensor_con_transformation [C D B : category] [F G : functor C D] (K : functor B C) (h : transformation F G)  : transformation (comp_functor K F) (comp_functor K G)
 ‚âî Struct_transformation (Œª M : category_Obj B, (transformation_Arr h (functor_Obj K M)));

 symbol constant_transformation [C D : category] [M N : category_Obj D] (a : category_Arr M N): transformation (constant_functor C M) (constant_functor C N) 
 ‚âî Struct_transformation (Œª M : category_Obj C, a);


symbol terminal_category : category ‚âî Struct_category one_Set (Œª F G, one_Set) (Œª F G H f g, One) (Œª F, One);
symbol terminal_intro_functor (C : category) : functor C terminal_category ‚âî constant_functor C One;

injective symbol category_Obj_functor [C : category] (M : category_Obj C) : functor terminal_category C
‚âî Struct_functor (Œª _, M) (Œª _ _ _, category_Iden M);
injective symbol category_Arr_transformation [C : category] [M N : category_Obj C] (a : category_Arr M N) : transformation (category_Obj_functor M) (category_Obj_functor N)
‚âî Struct_transformation (Œª _, a);

inductive natUniv  : TYPE ‚âî 
| Base_natUniv : ‚Ñï ‚Üí natUniv 
| Pair_natUniv : natUniv ‚Üí natUniv ‚Üí natUniv
// | InLeft_natUniv : natUniv ‚Üí  natUniv
// | InRight_natUniv : natUniv ‚Üí  natUniv
| Undefined_natUniv : natUniv;
symbol natUniv_Set : Set; rule œÑ natUniv_Set ‚Ü™ natUniv;
symbol natUniv_eq : natUniv ‚Üí natUniv ‚Üí ùîπ;
rule  natUniv_eq (Base_natUniv $x) (Base_natUniv $y) ‚Ü™ eqn $x $y 
with natUniv_eq (Base_natUniv $x) (Pair_natUniv $y1 $y2) ‚Ü™ false
with natUniv_eq (Base_natUniv $x) (Undefined_natUniv) ‚Ü™ false
with natUniv_eq (Pair_natUniv $y1 $y2) (Base_natUniv $x)  ‚Ü™ false
with natUniv_eq (Pair_natUniv $y1 $y2) (Undefined_natUniv)  ‚Ü™ false
with natUniv_eq (Pair_natUniv $x1 $x2) (Pair_natUniv $y1 $y2) ‚Ü™  (natUniv_eq $x1 $y1) and (natUniv_eq $x2 $y2)
with natUniv_eq (Undefined_natUniv) (Undefined_natUniv) ‚Ü™ true
with natUniv_eq (Undefined_natUniv) (Pair_natUniv $y1 $y2)   ‚Ü™ false
with natUniv_eq (Undefined_natUniv) (Base_natUniv $x)  ‚Ü™ false;
// with natUniv_eq (InLeft_natUniv $x) (InLeft_natUniv $y) ‚Ü™ natUniv_eq $x $y
// with natUniv_eq (InLeft_natUniv $x) (InRight_natUniv $y) ‚Ü™ false 

symbol natUniv_fst : natUniv ‚Üí natUniv;
symbol natUniv_snd : natUniv ‚Üí natUniv;
rule natUniv_fst (Pair_natUniv $1 $2) ‚Ü™ $1;
rule natUniv_snd (Pair_natUniv $1 $2) ‚Ü™ $2;

injective symbol listsub  (l : ùïÉ natUniv_Set) ‚âî  (`sub_ x : natUniv, istrue(‚àà natUniv_eq x l));

injective symbol liset_Arr_Set  (M : ùïÉ natUniv_Set) (N : ùïÉ natUniv_Set) : Set
‚âî natUniv_Set ‚Üí_ natUniv_Set;
injective symbol liset_Arr  (M : ùïÉ natUniv_Set) (N : ùïÉ natUniv_Set) ‚âî œÑ (liset_Arr_Set M N);

symbol liset_Comp  [M N L : ùïÉ natUniv_Set]  (f :  (liset_Arr M N)) (g : (liset_Arr N L)) : (liset_Arr M L)
‚âî Œª x, (g (f x));

injective symbol liset_Iden  M : (liset_Arr M M) ‚âî Œª x, x;

symbol liset ‚âî Struct_category (list natUniv_Set)  (liset_Arr_Set) (@liset_Comp) (liset_Iden);

//TODO MOVE to abstract
//TODO  memo keep also also naturality of limit_cov_transf
 constant symbol limit_cov_transf_rev : Œ†  [B J J' : cat] [W : mod J' J] [F : func J B] [F_‚áê_W : func J' B]
 (isl : limit_cov F W F_‚áê_W), Œ† [I : cat] (M : func I B),
 transf (Unit_mod M F_‚áê_W) Id_func (Imply_cov_mod ((Unit_mod M F)) W) Id_func;
//naturality
rule ($Z)_'‚àò> ($h '‚àò limit_cov_transf_rev $isl $M) 
‚Ü™ (($Z)_'‚àò> $h) ''‚àò limit_cov_transf_rev $isl ($Z ‚àò> $M);
// rule ($Z)_'‚àò> ($f '‚àò  (limit_cov_transf $isl)) 
// ‚Ü™  ( (_)_'‚àò> $f ) ''‚àò (limit_cov_transf $isl );


/// _______________

inductive empty : TYPE ‚âî ;
constant symbol empty_Set : Set;
rule œÑ (empty_Set) ‚Ü™ empty;
symbol rect_empty : Œ† [p0: (empty ‚Üí Set)], Œ† x: empty, œÑ (p0 x);

(p : Set) inductive option : TYPE ‚âî
| Some : œÑ p ‚Üí option p
| None : option p;
constant symbol option_Set : Set ‚Üí Set;
rule œÑ (option_Set $p) ‚Ü™ option $p;
symbol rect_option : Œ† [a0 : Set], Œ† [p0: (option a0 ‚Üí Set)], (Œ† x1: œÑ a0, œÑ (p0 (Some x1))) ‚Üí (œÑ (p0 (None ))) ‚Üí  Œ† x: option a0, œÑ (p0 x);
rule rect_option $1 $2 (Some $x) ‚Ü™ $1 $x;
rule rect_option $1 $2 (None) ‚Ü™ $2;



inductive graph : TYPE ‚âî | Struct_graph : Œ† 
(graph_Obj : Set) 
(graph_Arr : œÑ graph_Obj ‚Üí œÑ graph_Obj ‚Üí Set), graph;

injective symbol graph_Obj_Set (C : graph) : Set;
rule graph_Obj_Set (Struct_graph $graph_Obj $graph_Arr) ‚Ü™ $graph_Obj;
/* injective */ symbol graph_Obj (C : graph) : TYPE ‚âî œÑ (graph_Obj_Set C);
injective symbol graph_Arr_Set [C : graph]  : (graph_Obj C) ‚Üí (graph_Obj C) ‚Üí Set;
rule @graph_Arr_Set (Struct_graph $graph_Obj $graph_Arr) ‚Ü™ $graph_Arr;
symbol graph_Arr [C : graph]  : (graph_Obj C) ‚Üí (graph_Obj C) ‚Üí TYPE ‚âî Œª M N, œÑ (graph_Arr_Set M N);


//TODO quotient by assoc iden... this quotient is harrder to explain than expected because no way to remember that it is now a free category
// hmm in fact whole "concrete freely_category" is a bad idea, should directly do abstract (freely-)cat datatype on graph...
// injective symbol freely_category (C : graph) : category ‚âî Struct_category (graph_Obj_Set C) (@freely_category_Arr_Set C) (@freely_category_Comp C) (@freely_category_Iden C);

(C : graph) inductive diagram (D : category) : TYPE ‚âî | Struct_diagram [D] : Œ† 
(diagram_Obj : graph_Obj C ‚Üí category_Obj D) 
(diagram_Arr : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí category_Arr (diagram_Obj M) (diagram_Obj N)), diagram C D;

symbol diagram_Obj [C : graph] [D : category] (F : diagram C D) :  graph_Obj C ‚Üí category_Obj D;
rule diagram_Obj (Struct_diagram $diagram_Obj $diagram_Arr) ‚Ü™ $diagram_Obj;
symbol diagram_Arr [C : graph] [D : category] (F : diagram C D) :  Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí category_Arr (diagram_Obj F M) (diagram_Obj F N);
rule @diagram_Arr _ _ (Struct_diagram $diagram_Obj $diagram_Arr) ‚Ü™ $diagram_Arr;

(C D : graph) inductive graphMorph  : TYPE ‚âî | Struct_graphMorph : Œ† 
(graphMorph_Obj : graph_Obj C ‚Üí graph_Obj D) 
(graphMorph_Arr : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí graph_Arr (graphMorph_Obj M) (graphMorph_Obj N)), graphMorph C D;

symbol graphMorph_Obj [C : graph] [D : graph] (F : graphMorph C D) :  graph_Obj C ‚Üí graph_Obj D;
rule graphMorph_Obj (Struct_graphMorph $graphMorph_Obj $graphMorph_Arr) ‚Ü™ $graphMorph_Obj;
symbol graphMorph_Arr [C : graph] [D : graph] (F : graphMorph C D) :  Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí graph_Arr (graphMorph_Obj F M) (graphMorph_Obj F N);
rule @graphMorph_Arr _ _ (Struct_graphMorph $graphMorph_Obj $graphMorph_Arr) ‚Ü™ $graphMorph_Arr;

symbol comp_graphMorph_diagram [C' : graph] [C : graph] (F : graphMorph C' C) [D : category] (G : diagram C D) : diagram C' D
‚âî Struct_diagram (Œª M : graph_Obj C', diagram_Obj G (graphMorph_Obj F M)) (Œª (M N : graph_Obj C') a, (diagram_Arr G (graphMorph_Arr F a)));

/* injective */ symbol joinGraph_Obj [C : graph] (X Y : graph_Obj C) : Set ‚âî (graph_Obj_Set C) ;
injective symbol joinGraph_Arr [C : graph] (X Y : graph_Obj C) : Œ† (M N : œÑ (joinGraph_Obj X Y)), Set;
constant symbol joinGraph_Arr_introOld [C : graph] (X Y : graph_Obj C) : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí œÑ (joinGraph_Arr X Y M N);
constant symbol joinGraph_Arr_introNew [C : graph] (X Y : graph_Obj C) : œÑ (joinGraph_Arr X Y X Y);
symbol joinGraph_Arr_elim [C : graph] [X Y : graph_Obj C] : Œ† [E : œÑ (joinGraph_Obj X Y) ‚Üí œÑ (joinGraph_Obj X Y) ‚Üí Set]
 (first : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí œÑ (E M N)) (second: œÑ (E X Y)),
  Œ† (M N : graph_Obj C), œÑ (joinGraph_Arr X Y M N) ‚Üí œÑ (E M N);
rule (@joinGraph_Arr_elim $C $X $Y $E $oldarr $newarr _ _ (@joinGraph_Arr_introOld $C $X $Y _ _ $a)) ‚Ü™ ($oldarr _ _ $a);
rule (@joinGraph_Arr_elim $C $X $Y $E $oldarr $newarr _ _ (@joinGraph_Arr_introNew $C $X $Y)) ‚Ü™ ($newarr);
///todo review this eta necessarry?
rule (@joinGraph_Arr_elim _ $X $Y _ (@joinGraph_Arr_introOld _ $X $Y) (@joinGraph_Arr_introNew _ $X $Y)) ‚Ü™ Œª M N a, a;

injective symbol joinGraph [C : graph] (X Y : graph_Obj C): graph ‚âî Struct_graph (joinGraph_Obj X Y) (joinGraph_Arr X Y);

symbol joinGraph_graphMorph_Obj [C : graph] (X Y : graph_Obj C) : graph_Obj C ‚Üí graph_Obj (joinGraph X Y) ‚âî Œª x, x;
symbol joinGraph_graphMorph [C : graph] (X Y : graph_Obj C) : graphMorph C (joinGraph X Y) 
‚âî @Struct_graphMorph C (joinGraph X Y) (joinGraph_graphMorph_Obj X Y) (@joinGraph_Arr_introOld _ X Y);



/////////////----------

inductive  cone [C : graph] [D : category] (M : category_Obj D) (F : diagram C D) : TYPE ‚âî | Struct_cone [C D M F] : Œ†
(cone_Arr : Œ† (N : graph_Obj C), category_Arr M (diagram_Obj F N)), @cone C D M F ;

injective symbol cone_Arr [C D M F] (c : @cone C D M F) : Œ† (N : graph_Obj C), category_Arr M (diagram_Obj F N);
rule cone_Arr (Struct_cone $1) ‚Ü™ $1;

symbol tensor_cone [C B : graph] [D : category] (K: graphMorph B C) [M : category_Obj D] [F : diagram C D] (h : cone M F)
 : cone M (comp_graphMorph_diagram K F)
 ‚âî Struct_cone (Œª N : graph_Obj B, (cone_Arr h (graphMorph_Obj K N)));

symbol comp_con_cone  [D : category] [M' M : category_Obj D] (m : category_Arr M' M) [C : graph] [F : diagram C D] (t : cone M F) : cone M' F
 ‚âî Struct_cone (Œª N : graph_Obj C, category_Comp m (cone_Arr t N));


inductive limit' [C : graph] [D : category] (F : diagram C D) : TYPE ‚âî | Struct_limit' [C D F]: Œ†
(limit'_Obj : category_Obj D) 
(limit'_Cone : cone limit'_Obj F)
(limit'_Univ : Œ† [M : category_Obj D] (t : cone M F), category_Arr M limit'_Obj), @limit' C D F;

injective symbol limit'_Obj [C D F] (lim_F : @limit' C D F) : category_Obj D;
rule limit'_Obj (Struct_limit' $1 $2 $3) ‚Ü™ $1;
injective symbol limit'_Cone [C D F] (lim_F : @limit' C D F) : cone (limit'_Obj lim_F) F;
rule limit'_Cone (Struct_limit' $1 $2 $3) ‚Ü™ $2;
injective symbol limit'_Univ [C D F] (lim_F : @limit' C D F) : Œ† [M : category_Obj D] (t : cone M F), category_Arr M (limit'_Obj lim_F);
rule @limit'_Univ _ _ _ (Struct_limit' $1 $2 $3) ‚Ü™ $3;

inductive equalizing [C : graph] [X Y : graph_Obj C] [D : category] [M : category_Obj D] (F : diagram (joinGraph X Y) D)
(t : cone M (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F)): TYPE ‚âî | Struct_equalizing [C X R D M F t] :
Œ† (equalizing_Obj : category_Obj D) 
(equalizing_Arr : category_Arr (equalizing_Obj) M)
(equalizing_Cone : cone (equalizing_Obj) F), @equalizing C X R D M F t;

injective symbol equalizing_Obj [C X R D M F t] (e : @equalizing C X R D M F t): category_Obj D;
rule equalizing_Obj (Struct_equalizing $1 $2 $3) ‚Ü™ $1;
injective symbol equalizing_Arr [C X R D M F t] (e : @equalizing C X R D M F t): category_Arr (@equalizing_Obj C X R D M F t e) M;
rule equalizing_Arr (Struct_equalizing $1 $2 $3) ‚Ü™ $2;
injective symbol equalizing_Cone [C X R D M F t] (e : @equalizing C X R D M F t): cone (@equalizing_Obj C X R D M F t e) F;
rule equalizing_Cone (Struct_equalizing $1 $2 $3) ‚Ü™ $3;

inductive equalizer [C : graph] [X Y : graph_Obj C] [D : category] [M : category_Obj D] (F : diagram (joinGraph X Y) D)
(t : cone M (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F)): TYPE ‚âî | Struct_equalizer [C X R D M F t] : 
Œ† (equalizer_Equalizing : @equalizing C X R D M F t) 
(equalizer_Univ : Œ† e : @equalizing C X R D M F t, category_Arr (equalizing_Obj e) (equalizing_Obj equalizer_Equalizing)), @equalizer C X R D M F t;

injective symbol equalizer_Equalizing [C X R D M F t] (e : @equalizer C X R D M F t): @equalizing C X R D M F t;
rule equalizer_Equalizing (Struct_equalizer $1 $2) ‚Ü™ $1;
injective symbol equalizer_Univ [C X R D M F t] (e : @equalizer C X R D M F t): Œ† e' : @equalizing C X R D M F t, category_Arr (@equalizing_Obj C X R D M F t e') (@equalizing_Obj C X R D M F t (@equalizer_Equalizing C X R D M F t e));
rule equalizer_Univ (Struct_equalizer $1 $2) ‚Ü™ $2;



///---
symbol emptyGraph  : graph ‚âî Struct_graph (empty_Set ) (Œª _ _, empty_Set);

///---

/* injective */ symbol optionGraph_Obj (C : graph) : Set ‚âî  option_Set (graph_Obj_Set C);
injective symbol optionGraph_Arr (C : graph) : Œ† (M N : œÑ (optionGraph_Obj C)), Set;
constant symbol optionGraph_Arr_intro (C : graph) : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí œÑ (optionGraph_Arr C (Some M) (Some N));
symbol optionGraph_Arr_elim (C : graph) : Œ† [E : œÑ (optionGraph_Obj C) ‚Üí œÑ (optionGraph_Obj C) ‚Üí Set]
 (E_left : Œ† [M N : graph_Obj C], graph_Arr M N ‚Üí œÑ (E (Some M) (Some N)))  ,
  Œ† (M N : œÑ (optionGraph_Obj C)), œÑ (optionGraph_Arr C M N) ‚Üí œÑ (E M N);
rule (@optionGraph_Arr_elim $C $E $E_left  _ _ (@optionGraph_Arr_intro $C _ _ $a)) ‚Ü™ ($E_left _ _ $a);
///todo review this eta necessarry?
rule (@optionGraph_Arr_elim $C (optionGraph_Arr $C) (@optionGraph_Arr_intro $C)) ‚Ü™ Œª M N a, a;

injective symbol optionGraph (C : graph) : graph ‚âî Struct_graph (optionGraph_Obj C) (optionGraph_Arr C);

symbol optionGraph_graphMorph (C : graph) : graphMorph C (optionGraph C) 
‚âî @Struct_graphMorph C (optionGraph C) (Some) (@optionGraph_Arr_intro C);

///---

inductive terminal (D : category) : TYPE ‚âî | Struct_terminal [D] : 
Œ† (terminal_Obj : category_Obj D) 
(terminal_Univ : Œ† e : category_Obj D, category_Arr e (terminal_Obj)), @terminal D;

injective symbol terminal_Obj [D] (e : @terminal D): @category_Obj D;
rule terminal_Obj (Struct_terminal $1 $2) ‚Ü™ $1;
injective symbol terminal_Univ [D] (e : @terminal D): Œ† e' : @category_Obj D, category_Arr e' (@terminal_Obj D e);
rule terminal_Univ (Struct_terminal $1 $2) ‚Ü™ $2;




///-----

///---

inductive producing [C : graph]  [D : category] [M : category_Obj D] (F : diagram (optionGraph C) D)
(t : cone M (comp_graphMorph_diagram (optionGraph_graphMorph C) F)): TYPE ‚âî | Struct_producing [C D M F t] :
Œ† (producing_Obj : category_Obj D) 
(producing_Arr : category_Arr (producing_Obj) M)
(producing_Cone : cone (producing_Obj) F), @producing C D M F t;

injective symbol producing_Obj [C D M F t] (e : @producing C D M F t): category_Obj D;
rule producing_Obj (Struct_producing $1 $2 $3) ‚Ü™ $1;
injective symbol producing_Arr [C D M F t] (e : @producing C D M F t): category_Arr (@producing_Obj C D M F t e) M;
rule producing_Arr (Struct_producing $1 $2 $3) ‚Ü™ $2;
injective symbol producing_Cone [C D M F t] (e : @producing C D M F t): cone (@producing_Obj C D M F t e) F;
rule producing_Cone (Struct_producing $1 $2 $3) ‚Ü™ $3;

inductive product [C : graph]  [D : category] [M : category_Obj D] (F : diagram (optionGraph C) D)
(t : cone M (comp_graphMorph_diagram (optionGraph_graphMorph C) F)): TYPE ‚âî | Struct_product [C D M F t] : 
Œ† (product_Producing : @producing C D M F t) 
(product_Univ : Œ† e : @producing C D M F t, category_Arr (producing_Obj e) (producing_Obj product_Producing)), @product C D M F t;

injective symbol product_Producing [C D M F t] (e : @product C D M F t): @producing C D M F t;
rule product_Producing (Struct_product $1 $2) ‚Ü™ $1;
injective symbol product_Univ [C D M F t] (e : @product C D M F t): Œ† e' : @producing C D M F t, category_Arr (@producing_Obj C D M F t e') (@producing_Obj C D M F t (@product_Producing C D M F t e));
rule product_Univ (Struct_product $1 $2) ‚Ü™ $2;

///-----


inductive isFiniteGraph : graph ‚Üí TYPE ‚âî
| EmptyGraph_isFiniteGraph : isFiniteGraph emptyGraph 
| OptionGraph_isFiniteGraph [C : graph] : isFiniteGraph C ‚Üí isFiniteGraph (optionGraph C)
| JoinGraph_isFiniteGraph [C : graph]: isFiniteGraph C ‚Üí Œ† (X Y : graph_Obj C), isFiniteGraph (joinGraph X Y) ;

symbol rect_isFiniteGraph : Œ† p0: (Œ† x0: graph, isFiniteGraph x0 ‚Üí Set), 
œÑ (p0 emptyGraph EmptyGraph_isFiniteGraph) ‚Üí 
(Œ† C: graph, Œ† x1: isFiniteGraph C, œÑ (p0 C x1) ‚Üí œÑ (p0 (optionGraph C) (OptionGraph_isFiniteGraph x1))) ‚Üí 
(Œ† C: graph, Œ† x3: isFiniteGraph C, Œ† X: graph_Obj C, Œ† Y: graph_Obj C, œÑ (p0 C x3) ‚Üí œÑ (p0 (joinGraph X Y) (JoinGraph_isFiniteGraph x3 X Y ))) ‚Üí 
Œ† x0: graph, Œ† x: isFiniteGraph x0, œÑ (p0 x0 x);
rule @rect_isFiniteGraph $1 $2 $3 $4 $5 (@EmptyGraph_isFiniteGraph) ‚Ü™
  $2 ;
rule @rect_isFiniteGraph $1 $2 $3 $4 $5 (@OptionGraph_isFiniteGraph $6 $7) ‚Ü™
  $3 $6 $7 (@rect_isFiniteGraph $1 $2 $3 $4 $6 $7);
rule @rect_isFiniteGraph $1 $2 $3 $4 $5 (@JoinGraph_isFiniteGraph $6 $7 $8 $9) ‚Ü™
  $4 $6 $7 $8 $9 (@rect_isFiniteGraph $1 $2 $3 $4 $6 $7);



symbol lemma_ind_hypothesis_equalizer_limit : Œ† D, (Œ† [C X R M F t], @equalizer C X R D M F t) ‚Üí 
Œ† [C : graph] [X Y : graph_Obj C] (C_isf : isFiniteGraph C), 
(Œ† (F' : diagram C D), @limit' C D F') ‚Üí
Œ† (F : diagram (joinGraph X Y) D), @limit' (joinGraph X Y) D F ‚âî 
begin
assume D eqs C X Y C_ist IH F; 

have IH_F : limit' (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F) 
{ refine (IH (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F)) };

have Eq_IH_F : equalizer F (limit'_Cone IH_F) 
{ refine (eqs _ _ _ _ F (limit'_Cone IH_F)) };  

apply @Struct_limit' 
{ refine (equalizing_Obj (equalizer_Equalizing Eq_IH_F)) } 

{ refine (equalizing_Cone (equalizer_Equalizing Eq_IH_F)) }

{ assume M c_;

    have Eq_side : category_Arr M (limit'_Obj IH_F) 
    { refine (limit'_Univ IH_F) (tensor_cone (joinGraph_graphMorph X Y) c_) }; 

    refine (equalizer_Univ Eq_IH_F (Struct_equalizing M Eq_side c_ )) ; };
end;

// ---------


symbol liset_terminal : 
  terminal liset ‚âî
begin
refine Struct_terminal _ _ 
{  refine (Base_natUniv 0 ‚∏¨ ‚ñ°)  
}
{ refine Œª M x, Base_natUniv 0
};
end;

symbol foldl [b] [a] (f : œÑ b ‚Üí œÑ a ‚Üí  œÑ b) (i : œÑ b) : ùïÉ a ‚Üí œÑ b;

rule foldl $f $i ‚ñ°  ‚Ü™ $i
with foldl $f $i ($x ‚∏¨ $l) ‚Ü™ $f (foldl $f $i $l) $x ;
compute foldl (‚ãÖ) ‚ñ° ((1 ‚∏¨ 2 ‚∏¨ ‚ñ°) ‚∏¨ (5 ‚∏¨ 6 ‚∏¨ ‚ñ°) ‚∏¨ ‚ñ°);
symbol flatten [a] : ùïÉ (list a) ‚Üí ùïÉ a ‚âî foldl (‚ãÖ) ‚ñ°; //rev

symbol liset_product : 
Œ† [A: graph], Œ† [L: category_Obj liset], 
  Œ† F: diagram (optionGraph A) liset, 
  Œ† t: cone L (comp_graphMorph_diagram (optionGraph_graphMorph A) F), 
  product F t ‚âî
begin
assume A L F t;
refine Struct_product _ _ 
{  refine Struct_producing _ _ _ 
  { refine (flatten (map (Œª x, map (Pair_natUniv x) (diagram_Obj F None)) L));
  }
  { refine natUniv_fst;    
  }
  { refine (Struct_cone _);
  simplify;
  refine rect_option _ _
    { assume M; refine (Œª x, (cone_Arr t M) (natUniv_fst x));
    }
    { refine natUniv_snd
    };
  }
}
{
admit
};
end;


symbol liset_equalizer : 
Œ† [A: graph], Œ† [X: graph_Obj A], Œ† [Y: graph_Obj A], Œ† [L: category_Obj liset], 
  Œ† F: diagram (joinGraph X Y) liset, 
  Œ† t: cone L (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F), 
  equalizer F t ‚âî
begin
assume A X Y L F t;
refine Struct_equalizer _ _ 
{  refine Struct_equalizing _ _ _ 
  { refine (let f ‚âî (category_Comp (cone_Arr t X) (diagram_Arr F (joinGraph_Arr_introNew X Y))) in 
      let g ‚âî (cone_Arr t Y) in 
      filter (Œª x, natUniv_eq (f x) (g x)) L) ;
  }
  { refine (Œª x : natUniv, x);    
  }
  { refine (Struct_cone _);
    refine (Œª M,  category_Comp (Œª x : natUniv, x) ((cone_Arr t M)));
  }
}
{
admit
};
end;


//data for the main example
symbol onearrowthreeverticesgraph : graph ‚âî begin
refine (@joinGraph _ _ _ ) 
{ refine (optionGraph (optionGraph (optionGraph emptyGraph) ) )
}
{ refine (Some None)
}
{ refine (None)
}
end;

symbol onearrowthreeverticesgraph_isf : isFiniteGraph onearrowthreeverticesgraph ‚âî 
begin
refine (@JoinGraph_isFiniteGraph _ _ _ _ ) ;
refine (@OptionGraph_isFiniteGraph _ _) ;
refine (@OptionGraph_isFiniteGraph _ _) ;
refine (@OptionGraph_isFiniteGraph _ _) ;
refine (@EmptyGraph_isFiniteGraph ) ;
end;


symbol oneconstanttwobinaryoneternarydiagram : diagram onearrowthreeverticesgraph liset
‚âî begin
refine Struct_diagram _ _ 
{ 
  refine rect_option _ _ 
  { 
    refine rect_option _ _ 
    { 
      refine rect_option _ _  
      { 
        refine rect_empty
      }
      {
        refine ((Base_natUniv 13) ‚∏¨ (Base_natUniv 12) ‚∏¨ (Base_natUniv 11) ‚∏¨ ‚ñ°)
      }
    }
    {
      refine ((Base_natUniv 22) ‚∏¨ (Base_natUniv 21) ‚∏¨ ‚ñ°)
    }
  }
  {
    refine ((Base_natUniv 32) ‚∏¨ (Base_natUniv 31) ‚∏¨ ‚ñ°)
  }  
}
{  
  refine (joinGraph_Arr_elim _ _ )
  { 
    refine (optionGraph_Arr_elim _ _ );
    refine (optionGraph_Arr_elim _ _ );
    refine (optionGraph_Arr_elim _ _ );
    assume M N; 
    refine rect_empty
  }
  { 
    refine (Œª x, Base_natUniv 31)
  }
}
end;

/// other data for side examples
symbol twoverticesgraph : graph ‚âî begin
refine Struct_graph _ _ 
{ refine listsub (/* (Base_natUniv 3) ‚∏¨  */(Base_natUniv 2) ‚∏¨ (Base_natUniv 1) ‚∏¨ ‚ñ°);
}
{ refine (Œª M N, empty_Set);
}
end; //abort;

symbol twoverticesgraph_X : graph_Obj twoverticesgraph ‚âî (Struct_sub (Base_natUniv 1) top);
symbol twoverticesgraph_Y : graph_Obj twoverticesgraph ‚âî (Struct_sub (Base_natUniv 2) top);


symbol joinconstanttwobinarydiagram : diagram (@joinGraph twoverticesgraph twoverticesgraph_X twoverticesgraph_Y) liset
‚âî begin
refine Struct_diagram _ _ 
{ refine (Œª _, ((Base_natUniv 2) ‚∏¨ (Base_natUniv 1) ‚∏¨ ‚ñ°) )
}
{  refine (joinGraph_Arr_elim _ _ )
  { assume M N; simplify empty;
    refine rect_empty
  }
  { refine (Œª x, Base_natUniv 1)
  }
}
end;

symbol producttwobinary_Obj: category_Obj liset ‚âî
 (  Pair_natUniv (Base_natUniv 2)  (Base_natUniv 2)
 ‚∏¨  Pair_natUniv (Base_natUniv 2)  (Base_natUniv 1)
 ‚∏¨  Pair_natUniv (Base_natUniv 1)  (Base_natUniv 2)
 ‚∏¨  Pair_natUniv (Base_natUniv 1)  (Base_natUniv 1) ‚∏¨ ‚ñ°);

symbol producttwobinary_Cone : cone producttwobinary_Obj (comp_graphMorph_diagram (joinGraph_graphMorph twoverticesgraph_X twoverticesgraph_Y) joinconstanttwobinarydiagram) ‚âî
begin
refine Struct_cone _ ; simplify;
assume x;
refine if (natUniv_eq (sub_Fst x) (Base_natUniv 1) ) natUniv_fst 
(if (natUniv_eq (sub_Fst x) (Base_natUniv 2) ) natUniv_snd 
  (Œª _ , Undefined_natUniv));
end;

symbol example_liset_equalizer ‚âî liset_equalizer joinconstanttwobinarydiagram producttwobinary_Cone;
assert ‚ä¢ (equalizing_Obj (equalizer_Equalizing example_liset_equalizer ))
‚â° Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1) ‚∏¨ ‚ñ°) ;

symbol optionternarytwobinarydiagram : diagram (optionGraph twoverticesgraph) liset
‚âî begin
refine Struct_diagram _ _ 
{ refine (rect_option _ _)
  {
    refine (Œª _, ((Base_natUniv 2) ‚∏¨ (Base_natUniv 1) ‚∏¨ ‚ñ°) )
  }
  {
    refine (((Base_natUniv 9) ‚∏¨ (Base_natUniv 8) ‚∏¨ (Base_natUniv 7) ‚∏¨ ‚ñ°) )
  }
}
{ 
   refine (optionGraph_Arr_elim _ _);
    assume M N; simplify empty;
    refine rect_empty
}
end;

symbol example_liset_product ‚âî liset_product optionternarytwobinarydiagram producttwobinary_Cone;
compute (producing_Obj (product_Producing example_liset_product ));

assert ‚ä¢ (producing_Obj (product_Producing example_liset_product ))
‚â° Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 7) ‚∏¨ ‚ñ°)))))))))));



// ---------


//TODO: move to abstract librarry
symbol subst_Imply_cov_mod : 
Œ† [A B X : cat] [R : mod A B] [W : mod X B]
[I] (Z : func I B),
transf (Imply_cov_mod R W) Id_func (Imply_cov_mod (R <<‚àò Z) (W <<‚àò Z)) Id_func ‚âî
begin
assume A B X R W I Z;
refine (Lambda_cov_transf _);
refine ( (Eval_cov_transf (Id_transf _)) <<‚àò1 Z);
end;

// covariant yoneda action by cone of arrows, including functor image of cone  (remember: covariant yoneda action = contravariant yoneda embedding...)
injective symbol comp_Imply_cov_mod : Œ† [I A B J : cat] [F : func I A] [R : mod A B] [G : func I B],
hom F R G ‚Üí Œ† [K : cat] [N: func K B] [W : mod J K], 
transf (Imply_cov_mod (Unit_mod G N) W) F (Imply_cov_mod (R <<‚àò N) W) Id_func  ‚âî
begin
assume I A B J F R G h K N W;
refine (Lambda_cov_transf _);
refine ( (h ‚àò>'_(N)) ‚àò'' (Eval_cov_transf (Id_transf _))  );
end;

injective symbol limit_cov_univ : Œ†  [B J J' : cat] [W : mod J' J] [F : func J B] [F_‚áê_W : func J' B] (isl : limit_cov F W F_‚áê_W), 
Œ† [I : cat] [M : func I B] [I' : cat] [X : func I' I] [Y : func I' J'],
hom X (Imply_cov_mod ((Unit_mod M F)) W) Y ‚Üí hom X (Unit_mod M F_‚áê_W) Y;
// injective symbol limit_cov_univ' : Œ†  [B J J' : cat] [W : mod J' J] [F : func J B] [F_‚áê_W : func J' B] (isl : limit_cov F W F_‚áê_W), 
// Œ† [I : cat] [M : func I B],
// transf (Imply_cov_mod ((Unit_mod M F)) W) Id_func (Unit_mod M F_‚áê_W) Id_func;

//narrurality of limit intro
//WARRNING: this rule is necessarry because no such more general rule as: rule ($M)_'‚àò> ($g '‚àò $t) ‚Ü™ (($M)_'‚àò> $g) ''‚àò $t;
// which fails because $M is not id
rule $f '‚àò ($Z)_'‚àò> (limit_cov_univ $isl $c)  //this does not change M only restrict it, still lack comp of arrow with cone
‚Ü™  limit_cov_univ $isl ($f '‚àò ($Z)_'‚àò> $c);
// rule ($Z)_'‚àò> ($f '‚àò  (limit_cov_univ' $isl)) 
// ‚Ü™  ( (_)_'‚àò> $f ) ''‚àò (limit_cov_univ' $isl );

rule (limit_cov_univ $isl $c) ‚àò‚Üì $H ‚Ü™ limit_cov_univ $isl ($c ‚àò‚Üì $H);

injective symbol limit_cov_cone : Œ†  [B J J' : cat]  [W : mod J' J] [F : func J B] [F_‚áê_W : func J' B] (isl : limit_cov F W F_‚áê_W),
hom F_‚áê_W (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func;

//beta
rule (limit_cov_univ $isl $c) '‚àò (_)_'‚àò> (limit_cov_cone $isl) ‚Ü™ $c;
// rule (limit_cov_univ' $isl) ''‚àò ((_)_'‚àò> (limit_cov_cone $isl)) ‚Ü™ Id_transf _;

//eta
rule (limit_cov_univ $isl (limit_cov_cone $isl))  ‚Ü™ Func_cov_hom _ _;
// rule  ((_)_'‚àò> (limit_cov_cone $isl)) ''‚àò  (limit_cov_univ' $isl) ‚Ü™ Id_transf _;


injective symbol ilimit_Set [J' B : cat]  [J : cat] (F : func J B) (W : mod J' J) : Set ‚âî
`Œ£_ (F_‚áê_W : func J' B),
        (hom_Set F_‚áê_W (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func)
    √ó    (`Œ†_ [I : cat], `Œ†_ [M : func I B], `Œ†_ [I' : cat], `Œ†_ [S : func I' I], `Œ†_ [T : func I' J'],  /* TODO: T should Id_func ? */
    hom_Set S (Imply_cov_mod ((Unit_mod M F)) W) T ‚Üí_ hom_Set S (Unit_mod M F_‚áê_W) T);


injective symbol ilimit [J' B : cat]  [J : cat] (F : func J B) (W : mod J' J) : TYPE ‚âî œÑ (ilimit_Set F W);

injective symbol ilimit_limit_cov [J' B J F W] (F_‚áê_W : @ilimit J' B J F W) :
  limit_cov F W (sigma_Fst F_‚áê_W);
rule @limit_cov_univ _ _ _ _ _ _  (@ilimit_limit_cov $J' $B $J $F $W $F_‚áê_W)
 ‚Ü™ (sigma_Snd $F_‚áê_W)‚ÇÇ;
 rule @limit_cov_cone _ _ _ _ _ _  (@ilimit_limit_cov $J' $B $J $F $W $F_‚áê_W)
 ‚Ü™ (sigma_Snd $F_‚áê_W)‚ÇÅ;

////-----------

constant symbol graph_cat : Œ† C : graph, cat;
constant symbol graph_Obj_obj [C : graph] (M : graph_Obj C) : obj (graph_cat C); //TODO later as accumulator? for redirecting associativity
//TODO normalization operations define recursively by cases
symbol obj_graph_Obj [C : graph] (M : obj (graph_cat C)) : graph_Obj C;
rule (obj_graph_Obj (graph_Obj_obj $o)) ‚Ü™ $o; 


constant symbol graph_Arr_cov_arr [C : graph] (M N : obj (graph_cat C)) (a : graph_Arr (obj_graph_Obj M) (obj_graph_Obj N)) : 
arr M (Unit_mod Id_func (Obj_func N)) Terminal_obj;
constant symbol graph_Arr_con_arr [C : graph] (M N : obj (graph_cat C)) (a : graph_Arr (obj_graph_Obj M) (obj_graph_Obj N)) : 
arr Terminal_obj (Unit_mod (Obj_func M) Id_func) N;
//TODO: finish: graph viewed as unit profunctor
constant symbol graphunitprofunctor_Arr_arr [C : graph] (M N : obj (graph_cat C)) (a : graph_Arr (obj_graph_Obj M) (obj_graph_Obj N)) : 
arr M (Unit_mod Id_func Id_func) N;


//have both cov elim and con elim?, and separrated from (neutral) categoryunitprofunctor elim?
injective symbol graph_elim_cov_func [C : graph] : Œ† [E : cat]
(E_obj : Œ† (M : graph_Obj C), obj E)
(E_cov_arr : Œ† [M N : graph_Obj C] (a : graph_Arr M N), 
  arr (E_obj M) (Unit_mod Id_func (Obj_func (E_obj N))) Terminal_obj),
  func (graph_cat C) E;

//TODO later as accumulator? for redirecting associativity
rule  $M ‚àò>o (graph_elim_cov_func $E_obj $E_cov_arr)
  ‚Ü™ $E_obj (obj_graph_Obj $M);
rule (Func_cov_hom (graph_elim_cov_func $E_obj $E_cov_arr) _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr $M $N $a)
  ‚Ü™ ($E_cov_arr (obj_graph_Obj $M) (obj_graph_Obj $N) $a);

//eta  review this
symbol graph_elim_cov_func_Obj [C : graph] [E : cat]
(F : func (graph_cat C) E):
Œ† (M : graph_Obj C), obj E;
// ‚âî Œª M, (graph_Obj_obj M) ‚àò>o F;
rule @graph_elim_cov_func_Obj $C $E $F $M ‚Ü™ (graph_Obj_obj $M) ‚àò>o $F;

symbol graph_elim_cov_func_Arr [C : graph] [E : cat]
(F : func (graph_cat C) E):
Œ† [M N : graph_Obj C] (a : graph_Arr M N), 
  arr (graph_elim_cov_func_Obj F M) (Unit_mod Id_func (Obj_func (graph_elim_cov_func_Obj F N))) Terminal_obj;
// ‚âî Œª M N a, (Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr a);
rule (@graph_elim_cov_func_Arr $C $E $F $M $N $a) ‚Ü™ (Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr (graph_Obj_obj $M) (graph_Obj_obj $N) $a);
//eta
rule (graph_elim_cov_func (graph_elim_cov_func_Obj $F) (@graph_elim_cov_func_Arr _ _ $F))
  ‚Ü™ $F;

//TODO REVIEW THIS
// rule obj_graph_Obj ((graph_Obj_obj $X) ‚àò>o $F) ‚Ü™ obj_graph_Obj (graph_elim_cov_func_Obj $F $X);


//this says that the correspondence in the freely-category adjunction is  not only bijection but is also isomorphism/equivalence of categories
symbol graph_elim_cov_hom [C : graph] : Œ† [E  : cat] [G : func (graph_cat C) E] [F : func (graph_cat C) E] 
  (t_arr : Œ† (M : graph_Obj C), 
    arr ( (graph_Obj_obj M) ‚àò>o F) (Unit_mod Id_func (G <‚àò (Obj_func (graph_Obj_obj M)))) Terminal_obj)
//   (t_nat : Œ† [M N : graph_Obj C] (a : graph_Arr M N), 
//  œÄ(((Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr (graph_Obj_obj M) (graph_Obj_obj N) a)) '‚àòa (( _ ) _'‚àò>  (Arr_hom (t_arr N)))
//  =  (t_arr M) '‚àòa (_)_'‚àò> (Arr_hom ((Func_cov_hom G _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr (graph_Obj_obj M) (graph_Obj_obj N) a)))))
  ,  hom F (Unit_mod Id_func G) Id_func;

//CHANGED
// rule (graph_elim_cov_hom $x) '‚àò (( _ ) _'‚àò>  (graph_elim_cov_hom $h))
//     ‚Ü™ graph_elim_cov_hom (Œª M,  ($x M) '‚àòa (( _ ) _'‚àò>  (Arr_hom ($h M)))) ;
rule (graph_elim_cov_hom $x) '‚àò (( _ ) _'‚àò>  (graph_elim_cov_hom $h))
    ‚Ü™ graph_elim_cov_hom (Œª M,  ($x M) '‚àòa (( _ ) _'‚àò>  (Arr_hom (Obj_func _) (Obj_func _) ($h M)))) ;

rule ((graph_elim_cov_hom $t_arr) ‚àò>'_ ( _ )) ‚àòa' (Id_cov_arr (graph_Obj_obj $M))
    ‚Ü™ $t_arr $M ;

//TODO define category_elim_cov_hom from graphunitprofunctor_elim_hom ? or keep both because of rule below for interaction?
symbol  graphunitprofunctor_elim_hom [C : graph] : Œ† [A B: cat]  (F : func (graph_cat C) A) [R : mod A B] (G : func (graph_cat C) B) 
(t_arr : Œ† [M : graph_Obj C] [N : graph_Obj C] (r : graph_Arr M N),
              arr ((graph_Obj_obj M) ‚àò>o F) R ((graph_Obj_obj N) ‚àò>o G))

, hom F R G;

rule ((Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' ((graph_Arr_con_arr (graph_Obj_obj $M') (graph_Obj_obj $M) $a))) '‚àòa (_)_'‚àò> (graphunitprofunctor_elim_hom $F $G $t_arr)
‚Ü™ ($t_arr $M' $M $a);
// rule ((Func_cov_hom $F _) ‚àò>'_(_) ‚àò' (Arr_hom (graph_Arr_con_arr $a))) '‚àò (_)_'‚àò> (graphunitprofunctor_elim_hom $F $G $t_arr)
// ‚Ü™ ($t_arr _ _ $a);

//CHANGED
rule (graph_elim_cov_hom $x) '‚àò (_)_'‚àò> (graphunitprofunctor_elim_hom $F $G $t_arr)
‚Ü™ (graphunitprofunctor_elim_hom _ $G  (Œª M N r, ($x M) '‚àòa (_)_'‚àò> (Arr_hom _ (Obj_func _) ($t_arr _ _ r))));

// rule (graph_elim_cov_hom $x) '‚àò (_)_'‚àò> (graphunitprofunctor_elim_hom $F $G $t_arr)
// ‚Ü™ (graphunitprofunctor_elim_hom _ $G  (Œª M N r, ($x M) '‚àò (_)_'‚àò> ($t_arr _ _ r)));

//TODO redo this with presheaves grammatical entry...
//QUESTIONABLE, USED in old alternative abstract lemma_ind_base_iterminal_ilimit  but not in the new more relevant
symbol graph_elim_cov_transf [C : graph] : 
Œ† [A' A : cat] [F : func A' A]
[W : mod A' (graph_cat C)] [R : mod A (graph_cat C)] 
(t_arr : Œ† [N : graph_Obj C] ,
    transf (W  <<‚àò (Obj_func (graph_Obj_obj N))) 
          F (R  <<‚àò (Obj_func (graph_Obj_obj N))) Id_func )

, transf W F R Id_func;

rule (graph_elim_cov_transf $t_arr) <<‚àò1 (Obj_func (graph_Obj_obj $N)) ‚Ü™ ($t_arr $N);


constant symbol graphMorph_func [C : graph] [E : graph] (F : graphMorph C E):
func (graph_cat C) (graph_cat E);
//  ‚âî
// begin
//   assume C E F;
// refine graph_elim_cov_func _ _ 
// { assume M; 
//   refine (graph_Obj_obj (graphMorph_Obj F M));
//  }
// { assume M N a;
//   refine (Arr_hom (graph_Arr_cov_arr (graphMorph_Arr F a)));
// };
// proofterm;
// //Œª C E F, graph_elim_cov_func (Œª M, graph_Obj_obj (graphMorph_Obj F M)) (Œª M N a, Arr_hom (graph_Arr_cov_arr (graphMorph_Arr F a)))
// end;
/* rule @graphMorph_func $C $E $F ‚Ü™ graph_elim_cov_func (Œª M, graph_Obj_obj (graphMorph_Obj $F M)) (Œª M N a, (graph_Arr_cov_arr _ _ (graphMorph_Arr $F a))); */
rule  $M ‚àò>o (graphMorph_func $F) ‚Ü™ graph_Obj_obj (graphMorph_Obj $F (obj_graph_Obj $M));
rule (Func_cov_hom (graphMorph_func $F) _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr $M $N $a)
‚Ü™ (graph_Arr_cov_arr _ _ (graphMorph_Arr $F $a));



////-----------

constant symbol category_cat : Œ† C : category, cat;

constant symbol category_Obj_obj [C : category] (M : category_Obj C) : obj (category_cat C); //TODO later as accumulator? for redirecting associativity
//TODO normalization operations define recursively by cases
symbol obj_category_Obj [C : category] (M : obj (category_cat C)) : category_Obj C;
rule (obj_category_Obj (category_Obj_obj $o)) ‚Ü™ $o; 


//TODO similar as some elim
//replace (Obj_func N) by any (func Terminal_cat _)
constant symbol category_Arr_cov_arr [C : category] (M N : obj (category_cat C)) 
(a : category_Arr (obj_category_Obj M) (obj_category_Obj N)) :
 arr M (Unit_mod Id_func (Obj_func N)) Terminal_obj;
 constant symbol category_Arr_cov_arr' [C : category] (M : obj (category_cat C)) (N : func Terminal_cat (category_cat C))
 (a : category_Arr (obj_category_Obj M /* ‚àò>o Id_func */ ) (obj_category_Obj (Terminal_obj ‚àò>o N))) :
  arr M (Unit_mod Id_func N) Terminal_obj;
  //not really cov anymore...
constant symbol category_Arr_cov_arr'' [C : category] (M : obj (category_cat C)) [C' : cat] (N : func C' (category_cat C)) (Y : obj C')
(a : category_Arr (obj_category_Obj M /* ‚àò>o Id_func */ ) (obj_category_Obj (Y ‚àò>o N))) :
  arr M (Unit_mod Id_func N) Y;

constant symbol category_Arr_con_arr [C : category] (M N : obj (category_cat C)) 
(a : category_Arr (obj_category_Obj M) (obj_category_Obj N)) :
arr Terminal_obj (Unit_mod (Obj_func M) Id_func) N;
//TODO: finish: category viewed as unit profunctor
constant symbol categoryunitprofunctor_Arr_arr [C : category] (M N : obj (category_cat C)) 
(a : category_Arr (obj_category_Obj M) (obj_category_Obj N)) :
arr M (Unit_mod Id_func Id_func) N;

rule (Arr_hom _ (Obj_func _) (category_Arr_cov_arr _ _ $x)) '‚àò (( _ ) _'‚àò>  (Arr_hom (Obj_func _) _ (category_Arr_cov_arr _ _ $h)))
    ‚Ü™ Arr_hom _ _ (category_Arr_cov_arr _ _ (category_Comp $x $h)) ;
rule (Arr_hom _ (Obj_func _) (category_Arr_cov_arr _ _  $x)) '‚àò (( _ ) _'‚àò>  (Arr_hom (Obj_func _) _ (categoryunitprofunctor_Arr_arr _ _ $h)))
    ‚Ü™ Arr_hom _ _ (categoryunitprofunctor_Arr_arr _ _ (category_Comp $x $h)) ;

//TODO normalization operations define recursively by cases
symbol arr_category_Arr [C : category] [I : cat] [F: func I (category_cat C)] [J : cat] [G: func J (category_cat C)] [M : obj I] [N : obj J] 
  (a : arr M (Unit_mod F G) N) :
 category_Arr (obj_category_Obj (M ‚àò>o F)) (obj_category_Obj (N ‚àò>o G)) ;

rule (arr_category_Arr (category_Arr_cov_arr _ _ $a)) ‚Ü™ $a;

symbol category_cov_arr_Arr [C : category] [J : cat] [G: func J (category_cat C)] [M : obj (category_cat C)] [N : obj J] 
(a : arr M (Unit_mod Id_func G) N)
: category_Arr (obj_category_Obj M) (obj_category_Obj (N ‚àò>o G)) ;

rule (category_cov_arr_Arr (category_Arr_cov_arr _ _ $a)) ‚Ü™ $a;

//have both cov elim and con elim?, and separrated from (neutral) categoryunitprofunctor elim?
injective symbol  category_elim_cov_func [C : category] : Œ† [E : cat]
(E_obj : Œ† (M : category_Obj C), obj E)
(E_cov_arr : Œ† [M N : category_Obj C] (a : category_Arr M N), 
  arr (E_obj M) (Unit_mod Id_func (Obj_func (E_obj N))) Terminal_obj)
// (E_cov_hom_nat : Œ† [M N : category_Obj C] (a : category_Arr M N) [M'] (b : category_Arr M' M), 
//   œÄ ((E_cov_arr M' M b) '‚àòa (( _ ) _'‚àò>  (Arr_hom (E_cov_arr M N a))) = E_cov_arr M' N (category_Comp b a)))
,  func (category_cat C) E;

//TODO later as accumulator? for redirecting associativity
// rule $M ‚àò>o ( category_elim_cov_func $E_obj $E_cov_arr)
//   ‚Ü™ $E_obj (obj_category_Obj $M);
rule $M ‚àò>o ( category_elim_cov_func $E_obj $E_cov_arr)
  ‚Ü™ $E_obj (obj_category_Obj $M);

// rule (Func_cov_hom ( category_elim_cov_func $E_obj $E_cov_arr) _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr $M $N $a)
//   ‚Ü™ $E_cov_arr $M $N $a;
//TODO redo this for general arrow on left and use its normalization on right
rule (Func_cov_hom ( category_elim_cov_func $E_obj $E_cov_arr) _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr $M $N $a)
  ‚Ü™ $E_cov_arr (obj_category_Obj $M) (obj_category_Obj $N) $a;

//TODO retry
// rule (Func_cov_hom ( category_elim_cov_func $E_obj $E_cov_arr) Id_func) ‚àò>'_(_) ‚àòa' $a
//   ‚Ü™ $E_cov_arr _ _ (category_cov_arr_Arr $a);

// rule (Func_cov_hom ( category_elim_cov_func $E_obj $E_cov_arr) _) ‚àò>'_(_) ‚àò' (Arr_hom (category_Arr_cov_arr $a))
//   ‚Ü™ $E_cov_arr _ _ $a;

//eta  review this
// symbol category_elim_cov_func_Obj [C : category] [E : cat]
// (F : func (category_cat C) E):
// Œ† (M : obj (category_cat C)), obj E;
// // ‚âî Œª M, (category_Obj_obj M) ‚àò>o F;
// rule @category_elim_cov_func_Obj $C $E $F $M ‚Ü™  $M ‚àò>o $F;
symbol category_elim_cov_func_Obj [C : category] [E : cat]
(F : func (category_cat C) E):
Œ† (M : category_Obj C), obj E;
// ‚âî Œª M, (category_Obj_obj M) ‚àò>o F;
rule @category_elim_cov_func_Obj $C $E $F $M ‚Ü™  (category_Obj_obj $M) ‚àò>o $F;

// symbol category_elim_cov_func_Arr [C : category] [E : cat]
// (F : func (category_cat C) E):
// Œ† [M N : obj (category_cat C)] (a : category_Arr (obj_category_Obj M) (obj_category_Obj N)), 
//   arr (category_elim_cov_func_Obj F M) (Unit_mod Id_func (Obj_func (category_elim_cov_func_Obj F N))) Terminal_obj;
// // ‚âî Œª M N a, (Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr a);
// rule (@category_elim_cov_func_Arr $C $E $F $M $N $a) ‚Ü™ (Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr $M $N $a);
symbol category_elim_cov_func_Arr [C : category] [E : cat]
(F : func (category_cat C) E):
Œ† [M N : category_Obj C] (a : category_Arr M N), 
  arr (category_elim_cov_func_Obj F M) (Unit_mod Id_func (Obj_func (category_elim_cov_func_Obj F N))) Terminal_obj;
// ‚âî Œª M N a, (Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr a);
rule (@category_elim_cov_func_Arr $C $E $F $M $N $a) ‚Ü™ (Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr (category_Obj_obj $M) (category_Obj_obj $N) $a);

// type Œª [C : category] [E : cat]
// (F : func (category_cat C) E), 
// category_elim_cov_func (category_elim_cov_func_Obj F) (@category_elim_cov_func_Arr _ _ F);

//eta
rule (category_elim_cov_func (category_elim_cov_func_Obj $F) (@category_elim_cov_func_Arr _ _ $F))
  ‚Ü™ $F;

//TODO REVIEW THIS
// rule obj_category_Obj ((category_Obj_obj $X) ‚àò>o $F) ‚Ü™ obj_category_Obj (category_elim_cov_func_Obj $F $X);
// rule obj_category_Obj ((graph_Obj_obj $X) ‚àò>o $F) ‚Ü™ obj_category_Obj (graph_elim_cov_func_Obj $F $X);

// rule arr_category_Arr ((Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr $a))
//    ‚Ü™ arr_category_Arr (category_elim_cov_func_Arr $F $a);


//(obj_category_Obj (graph_Obj_obj X ‚àò>o F))  (category_elim_cov_func_Obj $F (obj_category_Obj (graph_Obj_obj X)))
//this says that the correspondence in the freely-category adjunction is  not only bijection but is also isomorphism/equivalence of categories
symbol category_elim_cov_hom [C : category] : Œ† [E  : cat] [G : func (category_cat C) E] [F : func (category_cat C) E] 
  (t_arr : Œ† (M : category_Obj C), 
  arr ((category_Obj_obj M) ‚àò>o F) (Unit_mod Id_func (G <‚àò (Obj_func (category_Obj_obj M)))) Terminal_obj) //TODO  o<‚àò
//   (t_nat : Œ† [M N : category_Obj C] (a : category_Arr M N), 
//  œÄ(((Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr (category_Obj_obj M) (category_Obj_obj N) a)) '‚àòa (( _ ) _'‚àò>  (Arr_hom (t_arr N)))
//  =   (t_arr M) '‚àòa (_)_'‚àò> (Arr_hom ((Func_cov_hom G _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr (category_Obj_obj M) (category_Obj_obj N) a)))))
  ,  hom F (Unit_mod Id_func G) Id_func;

rule (category_elim_cov_hom $x) '‚àò (( _ ) _'‚àò>  (category_elim_cov_hom $h))
    ‚Ü™ category_elim_cov_hom (Œª M,  ($x M) '‚àòa (( _ ) _'‚àò>  (Arr_hom _ (Obj_func _) ($h M)))) ;

// rule (category_elim_cov_hom $x) '‚àò (( _ ) _'‚àò>  (category_elim_cov_hom $h))
//     ‚Ü™ category_elim_cov_hom (Œª M,  ($x M) '‚àò (( _ ) _'‚àò>  ($h M))) ;
rule  (category_elim_cov_hom $t_arr) ‚àò>'_(_) ‚àòa' (Id_cov_arr (category_Obj_obj $M))
‚Ü™ ($t_arr  $M );

//TODO define category_elim_cov_hom from categoryunitprofunctor_elim_hom ? or keep both because of rule below for interaction?
symbol  categoryunitprofunctor_elim_hom [C : category] : Œ† [A B: cat]  (F : func (category_cat C) A) [R : mod A B] (G : func (category_cat C) B) 
(t_arr : Œ† [M : category_Obj C] [N : category_Obj C] (r : category_Arr M N),
        arr ((category_Obj_obj M) ‚àò>o F) R ((category_Obj_obj N) ‚àò>o G))
//  (t_hom_nat : Œ† [M : category_Obj C] [N : category_Obj C] (r : category_Arr  M N),
//           Œ† [M' : category_Obj C] (a : category_Arr M' M),
//         œÄ (((Func_cov_hom F _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr (category_Obj_obj M') (category_Obj_obj M) a)) '‚àòa (_)_'‚àò> (Arr_hom (t_arr _ _ r))
//         = t_arr _ _ (category_Comp a r)))
, hom F R G;

rule ((Func_cov_hom $F _) ‚àò>'_(_) ‚àòa' (category_Arr_con_arr (category_Obj_obj $M') (category_Obj_obj $M) $a)) '‚àòa (_)_'‚àò> (categoryunitprofunctor_elim_hom $F $G $t_arr)
‚Ü™ ($t_arr $M' $M $a);
// rule ((Func_cov_hom $F _) ‚àò>'_(_) ‚àò' (Arr_hom (category_Arr_con_arr $a))) '‚àò (_)_'‚àò> (categoryunitprofunctor_elim_hom $F $G $t_arr)
// ‚Ü™ ($t_arr _ _ $a);

rule (category_elim_cov_hom $x) '‚àò (_)_'‚àò> (categoryunitprofunctor_elim_hom $F $G $t_arr)
‚Ü™ (categoryunitprofunctor_elim_hom _ $G  (Œª M N r, ($x M) '‚àòa (_)_'‚àò> (Arr_hom _ (Obj_func _) ($t_arr _ _ r))));

// rule (category_elim_cov_hom $x) '‚àò (_)_'‚àò> (categoryunitprofunctor_elim_hom $F $G $t_arr)
// ‚Ü™ (categoryunitprofunctor_elim_hom _ $G  (Œª M N r, ($x M) '‚àò (_)_'‚àò> ($t_arr _ _ r)));

//TODO redo this with presheaves grammatical entry...
symbol category_elim_cov_transf [C : category] : 
Œ† [A' A : cat] [F : func A' A]
[W : mod A' (category_cat C)] [R : mod A (category_cat C)] 
(t_arr : Œ† [N : category_Obj C] ,
    transf (W  <<‚àò (Obj_func (category_Obj_obj N))) 
          F (R  <<‚àò (Obj_func (category_Obj_obj N))) Id_func )

, transf W F R Id_func;

rule (category_elim_cov_transf $t_arr) <<‚àò1 (Obj_func (category_Obj_obj $N)) ‚Ü™ ($t_arr $N);


constant symbol diagram_func [C : graph] [E : category] (F : diagram C E):
func (graph_cat C) (category_cat E) ;
// ‚âî begin
//   assume C E F;
//   refine graph_elim_cov_func _ _ 
// { assume M; 
//   refine (category_Obj_obj (diagram_Obj F M));
// }
// { assume M N a;
//   refine ((category_Arr_cov_arr (diagram_Arr F a)));
// };
// proofterm;
// end;
//Œª C E F, graph_elim_cov_func (Œª M, category_Obj_obj (diagram_Obj F M)) (Œª M N a, category_Arr_cov_arr (diagram_Arr F a))
/* rule @diagram_func $C $E $F ‚Ü™ graph_elim_cov_func (Œª M, category_Obj_obj (diagram_Obj $F M)) (Œª M N a, category_Arr_cov_arr _ _ (diagram_Arr $F a)); */
rule $M ‚àò>o (diagram_func $F) ‚Ü™ category_Obj_obj (diagram_Obj $F (obj_graph_Obj $M));
rule (Func_cov_hom (diagram_func $F) _) ‚àò>'_(_) ‚àòa' (graph_Arr_cov_arr $M $N $a)
‚Ü™ category_Arr_cov_arr _ _ (diagram_Arr $F $a);

//extra rules for extra special constants
rule graphMorph_func $H ‚àò> diagram_func $F ‚Ü™ diagram_func (comp_graphMorph_diagram $H $F);

constant symbol functor_func [C E : category] (F : functor C E):
func (category_cat C) (category_cat E) ;
// ‚âî begin
//   assume C E F;
//   refine graph_elim_cov_func _ _ 
// { assume M; 
//   refine (category_Obj_obj (diagram_Obj F M));
// }
// { assume M N a;
//   refine ((category_Arr_cov_arr (diagram_Arr F a)));
// };
// proofterm;
// end;
//Œª C E F, category_elim_cov_func (Œª M, category_Obj_obj (functor_Obj $F M)) (Œª M N a, category_Arr_cov_arr _ _ (functor_Arr $F a))
/* rule  @functor_func $C $E $F ‚Ü™ category_elim_cov_func (Œª M, category_Obj_obj (functor_Obj $F M)) (Œª M N a, category_Arr_cov_arr _ _ (functor_Arr $F a)); */
rule $M ‚àò>o (functor_func $F) ‚Ü™ category_Obj_obj (functor_Obj $F (obj_category_Obj $M));
rule (Func_cov_hom (functor_func $F) _) ‚àò>'_(_) ‚àòa' (category_Arr_cov_arr $M $N $a)
‚Ü™ category_Arr_cov_arr _ _ (functor_Arr $F $a);



constant symbol transformation_con_hom : Œ† [C D : category] [F G : functor C D] (h : transformation F G), 
hom Id_func (Unit_mod (functor_func F) Id_func) (functor_func G);
constant symbol transformation_cov_hom : Œ† [C D : category] [F G : functor C D] (h : transformation F G),
hom (functor_func F) (Unit_mod Id_func (functor_func G)) Id_func;
// begin
//   assume C D F G h;
//     refine category_elim_cov_hom _ ;
//     assume M; 
//     refine (category_Arr_cov_arr _ _ (transformation_Arr h M));
//     proofterm;
// //Œª C D F G h, category_elim_cov_hom (Œª M, category_Arr_cov_arr (category_Obj_obj M ‚àò>o functor_func F) (category_Obj_obj (functor_Obj G (obj_category_Obj (category_Obj_obj M)))) (transformation_Arr h M))
// abort;

rule  (@transformation_cov_hom _ _ $F $G $h) ‚àò>'_(_) ‚àòa' (Id_cov_arr (category_Obj_obj $M))
‚Ü™ (category_Arr_cov_arr (category_Obj_obj $M ‚àò>o functor_func $F) (category_Obj_obj (functor_Obj $G (obj_category_Obj (category_Obj_obj $M)))) (transformation_Arr $h $M) );

rule (transformation_cov_hom $x) '‚àò (( _ ) _'‚àò>  (transformation_cov_hom $h))
    ‚Ü™ transformation_cov_hom (comp_transformation $x $h) ;

///these extra conversion rules for transformation_cov_hom and functor_func are necessary? the equations versions should be derivable by deduction or metatheorem
rule (functor_func $F) ‚àò> (functor_func $G)
    ‚Ü™ functor_func (comp_functor $F $G) ;

rule  ((@transformation_cov_hom $C $D $F $G $h) ‚àò>'_ ( _ )) ‚àò' (@transformation_cov_hom $C' $D' $F' $G' $y)
    ‚Ü™ transformation_cov_hom (comp_transformation (tensor_con_transformation $F' $h) (tensor_cov_transformation $y $G)) ;
// : hom (functor_func F' ‚àò> functor_func F) (Unit_mod Id_func (functor_func G) <<‚àò functor_func G') (Id_func <‚àò Id_func)

rule ((Func_cov_hom (functor_func $K) Id_func) ‚àò>'_ ( _ )) ‚àò' (transformation_cov_hom $h) 
    ‚Ü™ (transformation_cov_hom (tensor_cov_transformation $h $K)) ;

rule (@transformation_cov_hom $C $D $F $G $h) '‚àò (( _ ) _'‚àò>  (Func_con_hom (functor_func $K) (functor_func $G)) )
    ‚Ü™ ((Func_con_hom (functor_func $K) (functor_func $F)) ‚àò>'_ ( _ ) /* cast */) ‚àò' (transformation_con_hom (tensor_cov_transformation $h $K)) ;
  
/////////////------------

//TODO ELIMINATION FOR FIBRATIONS
// symbol  category_elim_cov_funcs [C : category] : Œ† [E : catd (category_cat C)] //(E_isf : isFibration_con E)
// (E_obj : Œ† (M : category_Obj C), funcs (Obj_func (category_Obj_obj M)) E)
// (E_cov_arr : Œ† [M N : category_Obj C] (a : category_Arr M N), 
//    homs (Arr_hom _ _ (category_Arr_cov_arr _ _ a))  (E_obj M) (Unit_modd Id_funcd (Funcs_funcd (E_obj N))) (Func_funcs Id_func))
// // (E_nat : Œ† [M N : category_Obj C] (a : category_Arr M N), 
// //         œÄ (Fibration_con_funcd E_isf (E_obj N) (Arr_hom (category_Arr_con_arr a))
// //                     = Fibre_intro_funcd _ _ Id_func (E_obj M) ))
// ,  funcs Id_func E;

//COMMMENT
//TODO redo with objd (is funcs from terminal_cat) and arrd (is homds from terminal_cat besides terminal_catd)
symbol  category_elim_cov_funcd' :  //maybe quantify over abstract obj
Œ† [C: category], Œ† [E: catd (category_cat C)], // Œ† E_isf: isFibration_con E, //for E_nat

Œ† E_obj: (Œ† M: category_Obj C, funcd (Terminal_catd Terminal_cat) (Obj_func (category_Obj_obj M)) E), 

Œ† (E_cov_arr : Œ† M: category_Obj C, Œ† N: category_Obj C, Œ† a: category_Arr M N, 
      homd (Arr_hom (Obj_func (category_Obj_obj M)) Id_func 
                (category_Arr_cov_arr (category_Obj_obj M) (category_Obj_obj N) a)) 
          (E_obj M) (Unit_modd Id_funcd (E_obj N)) Id_funcd),

// Œ† (E_nat : Œ† M: category_Obj C, Œ† N: category_Obj C, Œ† a: category_Arr M N, 
//       œÄ (Fibration_con_funcd E_isf (E_obj N) 
//               (Arr_hom Id_func (Obj_func (category_Obj_obj N)) 
//                   (category_Arr_con_arr (category_Obj_obj M) (category_Obj_obj N) a)) 
//         = Fibre_intro_funcd E (Obj_func (category_Obj_obj M)) Id_func (E_obj M))),

funcd (Terminal_catd (category_cat C)) Id_func E;


//TODO: in adition to weightprof
(C D : category) inductive profunctor : TYPE ‚âî | Struct_profunctor : Œ† 
(profunctor_Arr : category_Obj C ‚Üí category_Obj D ‚Üí Set)
(profunctor_cov_Comp : Œ† [M : category_Obj C] [K L : category_Obj D], category_Arr K L ‚Üí œÑ (profunctor_Arr M K ‚Üí_ profunctor_Arr M L))
(profunctor_con_Comp : Œ† [M N : category_Obj C] [K : category_Obj D], category_Arr M N ‚Üí  œÑ (profunctor_Arr N K ‚Üí_ profunctor_Arr M K)), profunctor C D;
injective symbol profunctor_Arr [C D : category] (R : profunctor C D) : category_Obj C ‚Üí category_Obj D ‚Üí TYPE;
rule profunctor_Arr (Struct_profunctor $1 $2 $3) ‚Ü™ Œª M N, œÑ ($1 M N);
injective symbol profunctor_cov_Comp [C D : category] [R : profunctor C D] : Œ† [M : category_Obj C] [K L : category_Obj D], category_Arr K L ‚Üí  profunctor_Arr R M K ‚Üí profunctor_Arr R M L;
rule @profunctor_cov_Comp _ _ (Struct_profunctor $1 $2 $3) ‚Ü™ $2;
injective symbol profunctor_con_Comp [C D : category] [R : profunctor C D] : Œ† [M N : category_Obj C] [K : category_Obj D], category_Arr M N ‚Üí  profunctor_Arr R N K ‚Üí profunctor_Arr R M K;
rule @profunctor_con_Comp _ _ (Struct_profunctor $1 $2 $3) ‚Ü™ $3;


constant symbol profunctor_mod : Œ† [C D : category] (R : profunctor C D), mod (category_cat C) (category_cat D);
constant symbol profunctor_Arr_arr : Œ† [C D : category] [R : profunctor C D] (M : obj (category_cat C)) (N : obj (category_cat D)) (r : profunctor_Arr R (obj_category_Obj M) (obj_category_Obj N)),
 arr M (profunctor_mod R) N;


//////////------------

inductive iterminal (J' : cat) (B : cat)  : TYPE ‚âî 
| Struct_iterminal [J' B] : 
Œ† (iterminal_Func : func J' B) 
  (iterminal_Univ :  Œ† (I I' : cat) (e : func I' B), Œ† (S : func I I') (T : func I J'),  /* T should be Id_func */
                   hom S (Unit_mod e  iterminal_Func) T), 
   @iterminal J' B;

injective symbol iterminal_Func [J' B] (e : @iterminal J' B): func J' B;
rule iterminal_Func (Struct_iterminal $1 $2) ‚Ü™ $1;
injective symbol iterminal_Univ [J' B] (e : @iterminal J' B): Œ†  (I I' : cat) (e' : func I' B), Œ† (S : func I I') (T : func I J'), hom S (Unit_mod e'   (@iterminal_Func J' B e)) T ;
rule iterminal_Univ (Struct_iterminal $1 $2) ‚Ü™ $2;

////---------


inductive iproducing [J' : cat] [B : cat]  [A : graph]  
(F : func (graph_cat (optionGraph A)) B) (W : mod J' (graph_cat (optionGraph A)) )
[L : func J' B] 
(l : hom L (Imply_cov_mod ((Unit_mod Id_func 
    (F <‚àò (graphMorph_func (optionGraph_graphMorph A)))) ) 
    (W <<‚àò (graphMorph_func (optionGraph_graphMorph A)) )) Id_func) : TYPE ‚âî 
| Struct_iproducing [J' B A F W L l]  : Œ†
(I : cat) (I' : cat) (S : func I' I) (T : func I' J')
(iproducing_Func : func I B) 
(iproducing_Imply : hom S (Imply_cov_mod ((Unit_mod iproducing_Func F)) W) T)
(iproducing_Hom : hom S (Unit_mod iproducing_Func L) T), @iproducing J' B A F W L l;

injective symbol iproducing_I [J' B A F W L l] (e : @iproducing J' B A F W L l): cat;
rule iproducing_I (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $I;
injective symbol iproducing_I' [J' B A F W L l] (e : @iproducing J' B A F W L l): cat;
rule iproducing_I' (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $I';
injective symbol iproducing_S [J' B A F W L l] (e : @iproducing J' B A F W L l): func (iproducing_I' e) (iproducing_I e);
rule iproducing_S (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $S;
injective symbol iproducing_T [J' B A F W L l] (e : @iproducing J' B A F W L l): func (iproducing_I' e) J';
rule iproducing_T (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $T;

injective symbol iproducing_Func [J' B A F W L l] (e : @iproducing J' B A F W L l): func (iproducing_I e) B;
rule iproducing_Func (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $1;
injective symbol iproducing_Imply [J' B A F W L l] (e : @iproducing J' B A F W L l): hom (iproducing_S e) (Imply_cov_mod ((Unit_mod (@iproducing_Func J' B A F W L l e) F)) W) (iproducing_T e)  ;
rule iproducing_Imply (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $2;
injective symbol iproducing_Hom [J' B A F W L l] (e : @iproducing J' B A F W L l): hom (iproducing_S e) (Unit_mod (@iproducing_Func J' B A F W L l e) L) (iproducing_T e);
rule iproducing_Hom (Struct_iproducing $I $I' $S $T $1 $2 $3) ‚Ü™ $3;

inductive iproduct [J' : cat] [B : cat]  [A : graph]  
(F : func (graph_cat (optionGraph A)) B) (W : mod J' (graph_cat (optionGraph A)) )
[L : func J' B] 
(l : hom L (Imply_cov_mod ((Unit_mod Id_func  
    (F <‚àò (graphMorph_func (optionGraph_graphMorph A)))) ) 
    (W <<‚àò (graphMorph_func (optionGraph_graphMorph A)) )) Id_func) : TYPE ‚âî 
| Struct_iproduct [J' B A F W L l] : 
Œ† (iproduct_Func : func J' B) 
(iproduct_Hom : hom iproduct_Func (Unit_mod Id_func L) Id_func)
(iproduct_Imply : hom iproduct_Func (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func)
(iproduct_Univ : Œ† e : @iproducing J' B A F W L l, 
   hom (iproducing_S e) (Unit_mod (iproducing_Func e)  iproduct_Func) (iproducing_T e) ), 
   @iproduct J' B A F W L l;

injective symbol iproduct_Func [J' B A F W L l] (e : @iproduct J' B A F W L l): func J' B;
rule iproduct_Func (Struct_iproduct $1 $2 $3 $4) ‚Ü™ $1;
injective symbol iproduct_Hom [J' B A F W L l] (e : @iproduct J' B A F W L l): hom (@iproduct_Func J' B A F W L l e) (Unit_mod Id_func L) Id_func;
rule iproduct_Hom (Struct_iproduct $1 $2 $3 $4) ‚Ü™ $2;
injective symbol iproduct_Imply [J' B A F W L l] (e : @iproduct J' B A F W L l): hom (@iproduct_Func J' B A F W L l e) (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func;
rule iproduct_Imply (Struct_iproduct $1 $2 $3 $4) ‚Ü™ $3;
injective symbol iproduct_Univ [J' B A F W L l] (e : @iproduct J' B A F W L l): Œ† e' : @iproducing J' B A F W L l, hom (iproducing_S e') (Unit_mod (iproducing_Func e') (@iproduct_Func J' B A F W L l e) ) (iproducing_T e') ;
rule iproduct_Univ (Struct_iproduct $1 $2 $3 $4) ‚Ü™ $4;


/////////------------

inductive iqualizing [J' : cat] [B : cat]  [A : graph] [X : graph_Obj A] [Y : graph_Obj A] 
(F : func (graph_cat (joinGraph X Y)) B) (W : mod J' (graph_cat (joinGraph X Y)) )
[L : func J' B] 
(l : hom L (Imply_cov_mod ((Unit_mod Id_func 
    (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) ) 
    (W <<‚àò (graphMorph_func (joinGraph_graphMorph X Y)) )) Id_func) : TYPE ‚âî 
| Struct_iqualizing [J' B A X Y F W L l]  : Œ†
(I : cat) (I' : cat) (S : func I' I) (T : func I' J')
(iqualizing_Func : func I B) 
(iqualizing_Imply : hom S (Imply_cov_mod ((Unit_mod iqualizing_Func F)) W) T)
(iqualizing_Hom : hom S (Unit_mod iqualizing_Func L) T), @iqualizing J' B A X Y F W L l;

injective symbol iqualizing_I [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): cat;
rule iqualizing_I (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $I;
injective symbol iqualizing_I' [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): cat;
rule iqualizing_I' (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $I';
injective symbol iqualizing_S [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): func (iqualizing_I' e) (iqualizing_I e);
rule iqualizing_S (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $S;
injective symbol iqualizing_T [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): func (iqualizing_I' e) J';
rule iqualizing_T (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $T;

injective symbol iqualizing_Func [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): func (iqualizing_I e) B;
rule iqualizing_Func (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $1;
injective symbol iqualizing_Imply [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): hom (iqualizing_S e) (Imply_cov_mod ((Unit_mod (@iqualizing_Func J' B A X Y F W L l e) F)) W) (iqualizing_T e)  ;
rule iqualizing_Imply (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $2;
injective symbol iqualizing_Hom [J' B A X Y F W L l] (e : @iqualizing J' B A X Y F W L l): hom (iqualizing_S e) (Unit_mod (@iqualizing_Func J' B A X Y F W L l e) L) (iqualizing_T e);
rule iqualizing_Hom (Struct_iqualizing $I $I' $S $T $1 $2 $3) ‚Ü™ $3;

inductive iqualizer [J' : cat] [B : cat]  [A : graph] [X : graph_Obj A] [Y : graph_Obj A] 
(F : func (graph_cat (joinGraph X Y)) B) (W : mod J' (graph_cat (joinGraph X Y)) )
[L : func J' B] 
(l : hom L (Imply_cov_mod ((Unit_mod Id_func  
    (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) ) 
    (W <<‚àò (graphMorph_func (joinGraph_graphMorph X Y)) )) Id_func) : TYPE ‚âî 
| Struct_iqualizer [J' B A X Y F W L l] : 
Œ† (iqualizer_Func : func J' B) 
(iqualizer_Hom : hom iqualizer_Func (Unit_mod Id_func L) Id_func)
(iqualizer_Imply : hom iqualizer_Func (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func)
(iqualizer_Univ : Œ† e : @iqualizing J' B A X Y F W L l, 
   hom (iqualizing_S e) (Unit_mod (iqualizing_Func e)  iqualizer_Func) (iqualizing_T e) ), 
   @iqualizer J' B A X Y F W L l;

injective symbol iqualizer_Func [J' B A X Y F W L l] (e : @iqualizer J' B A X Y F W L l): func J' B;
rule iqualizer_Func (Struct_iqualizer $1 $2 $3 $4) ‚Ü™ $1;
injective symbol iqualizer_Hom [J' B A X Y F W L l] (e : @iqualizer J' B A X Y F W L l): hom (@iqualizer_Func J' B A X Y F W L l e) (Unit_mod Id_func L) Id_func;
rule iqualizer_Hom (Struct_iqualizer $1 $2 $3 $4) ‚Ü™ $2;
injective symbol iqualizer_Imply [J' B A X Y F W L l] (e : @iqualizer J' B A X Y F W L l): hom (@iqualizer_Func J' B A X Y F W L l e) (Imply_cov_mod ((Unit_mod Id_func F)) W) Id_func;
rule iqualizer_Imply (Struct_iqualizer $1 $2 $3 $4) ‚Ü™ $3;
injective symbol iqualizer_Univ [J' B A X Y F W L l] (e : @iqualizer J' B A X Y F W L l): Œ† e' : @iqualizing J' B A X Y F W L l, hom (iqualizing_S e') (Unit_mod (iqualizing_Func e') (@iqualizer_Func J' B A X Y F W L l e) ) (iqualizing_T e') ;
rule iqualizer_Univ (Struct_iqualizer $1 $2 $3 $4) ‚Ü™ $4;


(C : category) inductive weightprof (D : graph) : TYPE ‚âî | Struct_weightprof [D] : Œ† 
(weightprof_Arr : category_Obj C ‚Üí graph_Obj D ‚Üí Set)
(weightprof_cov_Comp : Œ† [M : category_Obj C] [K L : graph_Obj D], 
  graph_Arr K L ‚Üí 
    œÑ (weightprof_Arr M K ‚Üí_ weightprof_Arr M L)) 
(weightprof_con_Comp : Œ† [N : category_Obj C] [K : graph_Obj D] [M : category_Obj C],
    category_Arr M N ‚Üí 
   œÑ (weightprof_Arr N K ‚Üí_ weightprof_Arr M K))
, weightprof C D;

constant symbol weightprof_Set (C : category) (D : graph) : Set;
rule œÑ (weightprof_Set $C $D) ‚Ü™ weightprof $C $D;
injective symbol weightprof_Arr_Set [C : category] [D : graph] (R : weightprof C D) : category_Obj C ‚Üí graph_Obj D ‚Üí Set;
rule @weightprof_Arr_Set _ _ (Struct_weightprof $1 $2 $3) ‚Ü™ $1 ;
injective symbol weightprof_Arr [C : category] [D : graph] (R : weightprof C D) : category_Obj C ‚Üí graph_Obj D  ‚Üí TYPE ‚âî Œª M N, œÑ (weightprof_Arr_Set R  M N);
injective symbol weightprof_cov_Comp [C : category] [D : graph] [R : weightprof C D] : Œ† [M : category_Obj C] [K L : graph_Obj D], 
graph_Arr K L ‚Üí
  œÑ (weightprof_Arr_Set R M K ‚Üí_ weightprof_Arr_Set R M L);
rule @weightprof_cov_Comp _ _ (Struct_weightprof $1 $2 $3) ‚Ü™ $2;
injective symbol weightprof_con_Comp [C : category] [D : graph] [R : weightprof C D] : Œ† [N : category_Obj C] [K : graph_Obj D] [M : category_Obj C],
category_Arr M N ‚Üí 
 œÑ (weightprof_Arr_Set R N K ‚Üí_ weightprof_Arr_Set R M K);
rule @weightprof_con_Comp _ _ (Struct_weightprof $1 $2 $3) ‚Ü™ $3;


constant symbol weightprof_mod : Œ† [C : category] [D : graph] (R : weightprof C D), mod (category_cat C) (graph_cat D);

constant symbol weightprof_Arr_arr : Œ† [C : category] [D : graph] [R : weightprof C D] (M : obj (category_cat C)) (N : obj (graph_cat D)) (r : weightprof_Arr R (obj_category_Obj M) (obj_graph_Obj N)),
arr M (weightprof_mod R) N;
// TODO: todo generalize Id_func
rule ((category_Arr_cov_arr $M $N $h)) '‚àòa (_)_'‚àò> (Arr_hom _ _ (weightprof_Arr_arr $N $L $r))
   ‚Ü™ (weightprof_Arr_arr $M $L (weightprof_con_Comp $h $r));


   // rule ((category_Arr_cov_arr $h)) '‚àòa (_)_'‚àò> (Arr_hom (weightprof_Arr_arr $r))
//    ‚Ü™ (weightprof_Arr_arr (weightprof_con_Comp (category_Arr_cov_arr $h) $r));
// rule (Arr_hom (category_Arr_cov_arr $h)) '‚àò (_)_'‚àò> (Arr_hom (weightprof_Arr_arr $r))
//    ‚Ü™ Arr_hom (weightprof_Arr_arr (weightprof_con_Comp (category_Arr_cov_arr $h) $r));
// //todo generalize Id_func
// rule $h '‚àò (Id_func)_'‚àò> weightprof_Arr_arr $r
//    ‚Ü™ weightprof_Arr_arr (weightprof_con_Comp $h $r);

rule (Arr_hom _ _ (weightprof_Arr_arr _ $N $r)) ‚àò>'_ (_) ‚àòa' (graph_Arr_con_arr $N $L $a)
   ‚Ü™ (weightprof_Arr_arr _ $L (weightprof_cov_Comp $a $r));

symbol arr_weightprof_Arr [C : category] [D : graph] [R : weightprof C D] [M : obj (category_cat C)] [N : obj (graph_cat D)]  
(a : arr M (weightprof_mod R) N)
: weightprof_Arr R (obj_category_Obj M) (obj_graph_Obj N) ;
rule (arr_weightprof_Arr (weightprof_Arr_arr _ _ $a)) ‚Ü™ $a;

   //TODO both separrate cov and con? outer fixed M: transf (M o>> (weightprof_mod R')) (M o> F) R G;
 symbol  weightprof_elim_transf [A' : category] [B' : graph] [R' : weightprof A' B'] : Œ† [A B: cat]  (F : func (category_cat A') A) [R : mod A B] (G : func (graph_cat B') B) 
 (t_arr : Œ†  [M : category_Obj A'] [N : graph_Obj B'] (r : weightprof_Arr R' M N),
             arr ( (category_Obj_obj M) ‚àò>o F) R ((graph_Obj_obj N) ‚àò>o G))
//  (t_hom_con_nat : Œ† [M : category_Obj A'] [N : category_Obj B'] (r : weightprof_Arr R' M N),
//           Œ† [M' : category_Obj A'] (a : category_Arr M' M),
//         œÄ (((Func_cov_hom F _) ‚àò>'_(_) ‚àò' (category_Arr_cov_arr a)) '‚àò (_)_'‚àò> t_arr _ _ r
//         = t_arr _ _ (weightprof_con_Comp a r)))
// t_hom_cov_nat
, transf (weightprof_mod R') F R G;
rule ( (weightprof_Arr_arr (category_Obj_obj $M) (graph_Obj_obj $N) $r)) '‚àòa (weightprof_elim_transf $F $G $t_arr)
‚Ü™ ($t_arr _ _ $r);
rule (weightprof_elim_transf $F $G $t_arr) ‚àòa' ( (weightprof_Arr_arr (category_Obj_obj $M) (graph_Obj_obj $N) $r)) 
‚Ü™ ($t_arr _ _ $r);
// rule (Arr_hom (weightprof_Arr_arr $r)) '‚àò (weightprof_elim_transf $F $G $t_arr)
// ‚Ü™ ($t_arr _ _ $r);

/* //TODO review this alt
symbol  mod_elim_transf [A' : cat] [B' : graph] [R' : mod A' (graph_cat B')] : Œ† [A B: cat]  (F : func A' A) [R : mod A B] (G : func (graph_cat B') B) 
(t_arr : Œ†  [M : obj A'] [N : graph_Obj B'] (r : arr M R' (graph_Obj_obj N)),
            arr ( M ‚àò>o F) R ((graph_Obj_obj N) ‚àò>o G))
//  (t_hom_con_nat : Œ† [M : category_Obj A'] [N : category_Obj B'] (r : weightprof_Arr R' M N),
//           Œ† [M' : category_Obj A'] (a : category_Arr M' M),
//         œÄ (((Func_cov_hom F _) ‚àò>'_(_) ‚àò' (category_Arr_cov_arr a)) '‚àò (_)_'‚àò> t_arr _ _ r
//         = t_arr _ _ (weightprof_con_Comp a r)))
// t_hom_cov_nat
, transf R' F R G;
rule ( (weightprof_Arr_arr (graph_Obj_obj $M) $r)) '‚àòa (mod_elim_transf $F $G $t_arr)
‚Ü™ ($t_arr _ _ ( (weightprof_Arr_arr (graph_Obj_obj $M) $r)));
rule (mod_elim_transf $F $G $t_arr) ‚àòa' ( (weightprof_Arr_arr (graph_Obj_obj $M) $r)) 
‚Ü™ ($t_arr _ _ (weightprof_Arr_arr (graph_Obj_obj $M) $r));
 */
symbol weightprof_elim_transf_con_Arr [A' : category] [B' : graph] [R' : weightprof A' B'] [ B: cat]  [R : mod (category_cat A') B] [G : func (graph_cat B') B]
(t: transf (weightprof_mod R') Id_func R G) : 
 Œ†  (M : category_Obj A') (N : graph_Obj B') (r : weightprof_Arr R' M N),
 arr ( (category_Obj_obj M) ) R ((graph_Obj_obj N) ‚àò>o G);
// ‚âî Œª M N r, ((weightprof_Arr_arr (graph_Obj_obj _)  r)) '‚àòa t;
rule weightprof_elim_transf_con_Arr $t $M $N $r ‚Ü™ ((weightprof_Arr_arr  (category_Obj_obj $M) (graph_Obj_obj $N)  $r)) '‚àòa $t;
//instance eta for F=Id_func
rule (weightprof_elim_transf Id_func $G (@weightprof_elim_transf_con_Arr _ _ _ _ _ $G $t)) ‚Ü™ $t;

/* symbol mod_elim_transf_con_Arr [A' : cat] [B' : graph] [R' : mod A' (graph_cat B')] [ B: cat]  [R : mod A' B] [G : func (graph_cat B') B]
(t: transf R' Id_func R G) : 
 Œ†  (M : obj A') (N : graph_Obj B') (r : arr M R' (graph_Obj_obj N)),
 arr ( M ) R ((graph_Obj_obj N) ‚àò>o G);
 rule mod_elim_transf_con_Arr $t $M $N $r ‚Ü™ $r '‚àòa $t;
 rule (mod_elim_transf Id_func $G (@mod_elim_transf_con_Arr _ _ _ _ _ $G $t)) ‚Ü™ $t;
  */

symbol weightprof_elim_transf_cov_Arr [A' : category] [B' : graph] [R' : weightprof A' B'] [ A : cat] [F : func (category_cat A') A]  [R : mod A (graph_cat B')] 
(t: transf (weightprof_mod R') F R Id_func) : 
 Œ†  (M : category_Obj A') (N : graph_Obj B') (r : weightprof_Arr R' M N),
 arr ( (category_Obj_obj M) ‚àò>o F) R ((graph_Obj_obj N));
//‚âî Œª M N r, t ‚àòa' ( (weightprof_Arr_arr (graph_Obj_obj _) r));
rule weightprof_elim_transf_cov_Arr $t $M $N $r ‚Ü™ $t ‚àòa' ( (weightprof_Arr_arr (category_Obj_obj $M) (graph_Obj_obj $N) $r));
//instance eta for F=Id_func
rule (weightprof_elim_transf $F Id_func (@weightprof_elim_transf_cov_Arr _ _ _ _ $F _ $t))
‚Ü™ $t;

/* symbol mod_elim_transf_cov_Arr [A' : cat] [B' : graph] [R' : mod A' (graph_cat B')] [ A : cat] [F : func A' A]  [R : mod A (graph_cat B')] 
(t: transf R' F R Id_func) : 
 Œ†  (M : obj A') (N : graph_Obj B') (r : arr M R' (graph_Obj_obj N)),
 arr ( M ‚àò>o F) R ((graph_Obj_obj N));
//‚âî Œª M N r, t ‚àòa' ( (weightprof_Arr_arr (graph_Obj_obj _) r));
rule mod_elim_transf_cov_Arr $t $M $N $r ‚Ü™ $t ‚àòa' $r;
rule (mod_elim_transf $F Id_func (@mod_elim_transf_cov_Arr _ _ _ _ $F _ $t)) ‚Ü™ $t;
 */

symbol subst_cov_weightprof [C D] (R : weightprof C D) [E] (F : graphMorph E D) : weightprof C E ‚âî
begin 
  assume C D R E F;
  refine (Struct_weightprof (Œª M N, weightprof_Arr_Set R M (graphMorph_Obj F N)) _ _)
  { assume M K L a h;
  refine (weightprof_cov_Comp (graphMorph_Arr F a) h);
}
{ assume N K M a h;
  simplify;
  refine (weightprof_con_Comp a h);
};
// {admit;} {admit;};
end;

rule (weightprof_mod $R) <<‚àò (graphMorph_func $F)
‚Ü™ (weightprof_mod (subst_cov_weightprof $R $F));

symbol subst_con_weightprof [C D] (R : weightprof C D) [C'] (F : functor C' C) : weightprof C' D ‚âî
begin 
assume C D R C' F;
refine (Struct_weightprof (Œª M N, weightprof_Arr_Set R (functor_Obj F M ) N) _ _) 
{ assume M K L a h;
  refine (weightprof_cov_Comp a h);
}
{ assume N K M a h;
  simplify;
  refine (weightprof_con_Comp (functor_Arr F a ) h);
};
end;
rule (functor_func $F) ‚àò>> (weightprof_mod $R) 
‚Ü™ (weightprof_mod (subst_con_weightprof $R $F));


symbol terminal_weightprof (C : category) (D : graph) : weightprof C D ‚âî 
  Struct_weightprof (Œª M N, one_Set) (Œª M K L a r, One) (Œª N K M a r, One);
  
//could use Terminal_mod instead? but datatype is required, or add datatype properties on top of Terminal_mod
assert (C : category) (D : graph) (E : graph) (F : graphMorph E D) ‚ä¢ 
(weightprof_mod (terminal_weightprof C D )) <<‚àò (graphMorph_func F) ‚â° (weightprof_mod (terminal_weightprof C E ));


/////////-------------

/// note that concrete data cone produces abstract grammatical transf, not grammatical hom; but concrete data transformation do produces abstract grammatical hom
constant symbol cone_transf [C : graph] [D : category] [L : category_Obj D] [F : diagram C D] (h : cone L F) : 
transf (weightprof_mod (terminal_weightprof terminal_category C)) 
  (functor_func (category_Obj_functor L)) 
  (Unit_mod Id_func (diagram_func F)) Id_func;
// ‚âî begin
//   assume C D L F h; refine weightprof_elim_transf _ _ _ ;
//   assume _ N; simplify; 
//   assume _;
//   refine ( (category_Arr_cov_arr _  _ (cone_Arr h N))
//     '‚àòa ((Id_func)_'‚àò> Func_cov_hom (diagram_func F) (Obj_func (graph_Obj_obj N))) );
// abort;
//Œª C D L F h, weightprof_elim_transf (functor_func (category_Obj_functor L)) Id_func (Œª _ N _, category_Arr_cov_arr (category_Obj_obj L) (category_Obj_obj (diagram_Obj F (obj_graph_Obj (graph_Obj_obj N)))) (cone_Arr h N) '‚àòa (Id_func _'‚àò> Func_cov_hom (diagram_func F) (Obj_func (graph_Obj_obj N))))
rule (@cone_transf $C $D $L $F $h) ‚àòa' ( (weightprof_Arr_arr (category_Obj_obj $M) (graph_Obj_obj $N) $r)) 
‚Ü™ category_Arr_cov_arr (category_Obj_obj $L) (category_Obj_obj (diagram_Obj $F (obj_graph_Obj (graph_Obj_obj $N)))) (cone_Arr $h $N) '‚àòa (Id_func _'‚àò> Func_cov_hom (diagram_func $F) (Obj_func (graph_Obj_obj $N)));
//TODO review necessity of both rules
rule @weightprof_elim_transf_cov_Arr _ _ _ _ _ _ (@cone_transf $C $D $L $F $h) $M $N $r
‚Ü™ category_Arr_cov_arr (category_Obj_obj $L) (category_Obj_obj (diagram_Obj $F (obj_graph_Obj (graph_Obj_obj $N)))) (cone_Arr $h $N) '‚àòa (Id_func _'‚àò> Func_cov_hom (diagram_func $F) (Obj_func (graph_Obj_obj $N)));

//////---------

symbol lemma_ind_base_iterminal_ilimit' : Œ† (J': category), Œ† (B: cat), 
( iterminal (category_cat J') B ) ‚Üí 
Œ† F: func (graph_cat emptyGraph) B, 
Œ† W: weightprof J' emptyGraph, 
   ilimit F (weightprof_mod W)  ‚âî 
begin
assume J' B Hterminal F W; 

apply Struct_sigma
{ refine (iterminal_Func Hterminal); 
}
{ refine (_ & _)
  { refine (Lambda_cov_transf_hom _);

    refine (weightprof_elim_transf _ _ _);
    assume M; 
    simplify;
    refine rect_empty;

    // // ALT with questionable graph_elim_cov_transf
    // refine (graph_elim_cov_transf _);
    // simplify;
    // refine rect_empty;
  }
  { //TODO:   cone yoneda action ?
      //USE OF tensor_cone REQUIRED
    
    simplify;
    // assume I M T _;
    // refine (iterminal_Univ Hterminal _ M T);
    assume I M I' X Y _;
    refine (iterminal_Univ Hterminal _ _ M X Y);
  }
}
end;



  ////-----

symbol lemma_ind_hypothesis_iproduct_ilimit' : Œ† (J': category), Œ† (B: cat), 
(Œ† [A : graph] , 
  Œ† F: func (graph_cat (optionGraph A)) B, 
  Œ† W: weightprof J' (optionGraph A), 
  Œ† L: func (category_cat J') B, 
  Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func 
      (F <‚àò (graphMorph_func (optionGraph_graphMorph A)))) 
      ((weightprof_mod W) <<‚àò (graphMorph_func (optionGraph_graphMorph A)))) Id_func, 
  iproduct F (weightprof_mod W) l) ‚Üí 
Œ† (A : graph) , isFiniteGraph A ‚Üí 
(Œ† F1: func (graph_cat A) B, 
 Œ† W1: weightprof J' A, 
    ilimit F1 (weightprof_mod W1)) ‚Üí 
Œ† F: func (graph_cat (optionGraph A)) B, 
Œ† W: weightprof J' (optionGraph A), 
   ilimit F (weightprof_mod W)  ‚âî 
begin
assume J' B Hprod A A_isf IH F W; 
 
have lim_F_comp : ilimit (F <‚àò (graphMorph_func (optionGraph_graphMorph A))) 
                    ((weightprof_mod W) <<‚àò (graphMorph_func (optionGraph_graphMorph A))) 
{ refine (IH (F <‚àò (graphMorph_func (optionGraph_graphMorph A))) 
              (subst_cov_weightprof  W (optionGraph_graphMorph A))) 
};

have Prod_F_lim_F_comp : iproduct F (weightprof_mod W) ((sigma_Snd lim_F_comp)‚ÇÅ)
{ refine (Hprod _ F W _ ((sigma_Snd lim_F_comp)‚ÇÅ)) 
};  

apply Struct_sigma
{ refine (iproduct_Func Prod_F_lim_F_comp); 
}
{ refine (_ & _)
  { refine (iproduct_Imply Prod_F_lim_F_comp) 
  }
  { //USE OF tensor_cone REQUIRED, ... did use, this is subst_Imply_cov_mod 
    
  assume I M I' S T c_F;
    have c_F_side : œÑ (hom_Set S (Unit_mod M (sigma_Fst lim_F_comp)) T)
    { refine ((sigma_Snd lim_F_comp)‚ÇÇ _ _ _ _ _ 
      (c_F '‚àò (subst_Imply_cov_mod (graphMorph_func (optionGraph_graphMorph A))))) 
    };

    have c_F_iproducing : iproducing F (weightprof_mod W) ((sigma_Snd lim_F_comp)‚ÇÅ)
    { refine (@Struct_iproducing _  _ _ _ _ _ 
          ((sigma_Snd lim_F_comp)‚ÇÅ) _ _ _ _ M c_F c_F_side) 
    };
    
    refine (iproduct_Univ Prod_F_lim_F_comp 
              (@Struct_iproducing _ _ _ _ _ _ ((sigma_Snd lim_F_comp)‚ÇÅ) _ _ _ _ M c_F c_F_side)) ;
  }
}
end;

symbol lemma_ind_hypothesis_iqualizer_ilimit' : Œ† (J': category), Œ† (B: cat), 
(Œ† [A : graph] [X : graph_Obj A] [Y : graph_Obj A], 
  Œ† F: func (graph_cat (joinGraph X Y)) B, 
  Œ† W: weightprof J' (joinGraph X Y), 
  Œ† L: func (category_cat J') B, 
  Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func 
      (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) 
      ((weightprof_mod W) <<‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) Id_func, 
  iqualizer F (weightprof_mod W) l) ‚Üí 
Œ† (A : graph), isFiniteGraph A ‚Üí Œ† [X : graph_Obj A] [Y : graph_Obj A], 
(Œ† F1: func (graph_cat A) B, 
 Œ† W1: weightprof J' A, 
    ilimit F1 (weightprof_mod W1)) ‚Üí 
Œ† F: func (graph_cat (joinGraph X Y)) B, 
Œ† W: weightprof J'  (joinGraph X Y), 
   ilimit F (weightprof_mod W)  ‚âî 
begin
  assume J' B Hequa A A_isf X Y IH F W; 
 
have lim_F_comp : ilimit (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y))) ((weightprof_mod W) <<‚àò (graphMorph_func (joinGraph_graphMorph X Y))) 
{ refine (IH (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y))) (subst_cov_weightprof  W (joinGraph_graphMorph X Y))) };

 have Eq_F_lim_F_comp : iqualizer F (weightprof_mod W)  ((sigma_Snd lim_F_comp)‚ÇÅ)
{ refine (Hequa _ _ _ F W _ ((sigma_Snd lim_F_comp)‚ÇÅ)) };  

apply Struct_sigma
{ refine (iqualizer_Func Eq_F_lim_F_comp); }
{ refine (_ & _)
  {  refine (iqualizer_Imply Eq_F_lim_F_comp) }
  { assume I M I' S T c_F;
    have c_F_side : œÑ (hom_Set S (Unit_mod M (sigma_Fst lim_F_comp)) T)
    { refine ((sigma_Snd lim_F_comp)‚ÇÇ _ _ _ _ _ (c_F '‚àò (subst_Imply_cov_mod (graphMorph_func (joinGraph_graphMorph X Y))))) };

    have c_F_iqualizing : iqualizing F (weightprof_mod W)  ((sigma_Snd lim_F_comp)‚ÇÅ)
    { refine (@Struct_iqualizing _  _ _ _ _ _ _ _ ((sigma_Snd lim_F_comp)‚ÇÅ) _ _ _ _ M c_F c_F_side) };
    
    refine (iqualizer_Univ Eq_F_lim_F_comp (@Struct_iqualizing _ _ _ _ _ _ _ _ ((sigma_Snd lim_F_comp)‚ÇÅ) _ _ _ _ M c_F c_F_side)) ;
  }
}
end;



symbol lemma_data_terminal_iterminal : Œ† [J' B : category ], 
( terminal  B) ‚Üí
 iterminal (category_cat J') (category_cat B)   ‚âî
begin
  assume J' B Hterminal;

  refine Struct_iterminal _ _ 
  { refine category_elim_cov_func _ _
    { assume M;
      refine (category_Obj_obj (terminal_Obj Hterminal));
    }
    { admit;
    };
  }
  { assume I I' e S T;

    simplify;
    type (terminal_Univ Hterminal);
    admit;
  }
end;





symbol lemma_data_product_iproduct : Œ† [J' B : category ], 
(Œ† A: graph, Œ† L: category_Obj B, 
  Œ† F: diagram (optionGraph A) B, 
  Œ† t: cone L (comp_graphMorph_diagram (optionGraph_graphMorph A) F), 
  product F t) ‚Üí
(Œ† [A : graph],
   Œ† F: func (graph_cat (optionGraph A)) (category_cat B), 
  Œ† W: weightprof J'  (optionGraph A) ,
  Œ† [L: func (category_cat J') (category_cat B)], 
  Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func 
       (F <‚àò (graphMorph_func (optionGraph_graphMorph A)))) 
        ((weightprof_mod W) <<‚àò (graphMorph_func (optionGraph_graphMorph A)))) Id_func,
@iproduct (category_cat J') (category_cat B) A F (weightprof_mod W) L l )   ‚âî
begin
  assume J' B Hprod A F W L l;
 type (Œª M N a, arr_category_Arr (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l) M N a));

  // have l': Œ† M: obj (category_cat J'), Œ† N: œÑ (graph_Obj_Set A), œÑ (weightprof_Arr_Set (subst_cov_weightprof W (optionGraph_graphMorph A)) M N) ‚Üí category_Arr (obj_category_Obj ((M ‚àò>o L) ‚àò>o Id_func)) (obj_category_Obj (graph_Obj_obj N ‚àò>o (F <‚àò graphMorph_func (optionGraph_graphMorph A))))
  // { assume M N a;
  // simplify;

  //  refine (arr_category_Arr (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l) M N a)) 
  //  };


  have F_dia : diagram (optionGraph A) B
  { refine @Struct_diagram (optionGraph A) _ (Œª I: graph_Obj (optionGraph A), (obj_category_Obj (@graph_elim_cov_func_Obj (optionGraph A) _ F I))) 
      /* l' */ (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (optionGraph A) _ F M1 N1 a1)) ;        
  };

  have l_cone : Œ† M, cone (obj_category_Obj ((category_Obj_obj M) ‚àò>o L))
      (comp_graphMorph_diagram (optionGraph_graphMorph A) 
      /* F_dia */ (@Struct_diagram (optionGraph A) _ (Œª I : graph_Obj (optionGraph A), (obj_category_Obj (@graph_elim_cov_func_Obj (optionGraph A) _ F I))) 
              (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (optionGraph A) _ F M1 N1 a1))) )
  { refine Œª M, Struct_cone (Œª N, (Œª M N a, arr_category_Arr (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l) M N a)) M N _); 
  admit; /* TEST */
  };
  have l_Hprod : Œ† M, product /* F_dia */ (@Struct_diagram (optionGraph A) _ (Œª I : graph_Obj (optionGraph A), (obj_category_Obj (@graph_elim_cov_func_Obj (optionGraph A) _ F I))) 
  (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (optionGraph A) _ F M1 N1 a1)))
    (l_cone M)
  { refine (Œª M, Hprod A (obj_category_Obj ((category_Obj_obj M) ‚àò>o L))
    /* F_dia */ (@Struct_diagram (optionGraph A) _ (Œª I : graph_Obj (optionGraph A), (obj_category_Obj (@graph_elim_cov_func_Obj (optionGraph A) _ F I))) 
        (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (optionGraph A) _ F M1 N1 a1)))
    (l_cone M))
  }; 
  refine Struct_iproduct _ _ _ _
  { refine category_elim_cov_func _ _
    { assume M;
      refine (category_Obj_obj (producing_Obj (product_Producing (l_Hprod M))));
    }
    { admit;
    };
  }
  { refine category_elim_cov_hom _ ;
  assume M; simplify;
  apply (category_Arr_cov_arr (category_Obj_obj (producing_Obj (product_Producing (l_Hprod M)))) (category_Obj_obj M ‚àò>o L) (producing_Arr (product_Producing (l_Hprod M))));
  //category_Arr (producing_Obj (product_Producing (l_Hprod M))) (obj_category_Obj (category_Obj_obj M ‚àò>o L))
  }
  { refine (Lambda_cov_transf_hom (weightprof_elim_transf _ _ _));
    assume M N _ /* TEST */ ;
    simplify;
    type (category_Arr_cov_arr (category_Obj_obj (producing_Obj (product_Producing (l_Hprod M))))  ((graph_Obj_obj N) ‚àò>o F) (@cone_Arr (optionGraph A) _ _ _ (producing_Cone (product_Producing (l_Hprod M))) N));
    //category_Arr (producing_Obj (product_Producing (l_Hprod (obj_category_Obj M)))) (diagram_Obj (Struct_diagram (Œª I, obj_category_Obj (graph_elim_cov_func_Obj F I)) (Œª M1 N1 a1, arr_category_Arr (graph_elim_cov_func_Arr F a1))) N)
    refine ( (category_Arr_cov_arr _  _ (@cone_Arr (optionGraph A) _ _ _ (producing_Cone (product_Producing (l_Hprod M))) N))
    '‚àòa ((Id_func)_'‚àò> Func_cov_hom F (Obj_func (graph_Obj_obj N))) );
  }
  { assume e;
   simplify;
   type @func;
     //proofterm;
     admit;

  };
end; //abort;



/////////////////------------


symbol lemma_data_equalizer_iqualizer : Œ† [J' B : category ], 
(Œ† A: graph, Œ† X: graph_Obj A, Œ† Y: graph_Obj A, Œ† L: category_Obj B, 
  Œ† F: diagram (joinGraph X Y) B, 
  Œ† t: cone L (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F), 
  equalizer F t) ‚Üí
(Œ† [A : graph] [X : graph_Obj A] [Y : graph_Obj A],
   Œ† F: func (graph_cat (joinGraph X Y)) (category_cat B), 
  Œ† W: weightprof J'  (joinGraph X Y), //‚âî (terminal_weightprof _ _) in 
  Œ† [L: func (category_cat J') (category_cat B)], 
  Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func 
       (F <‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) 
        ((weightprof_mod W) <<‚àò (graphMorph_func (joinGraph_graphMorph X Y)))) Id_func,
@iqualizer (category_cat J') (category_cat B) A X Y F (weightprof_mod W) L l )   ‚âî
begin
  assume J' B Hequa A X Y F W L l;
  //transf (weightprof_mod W <<‚àò graphMorph_func (joinGraph_graphMorph X Y)) L (Unit_mod Id_func (F <‚àò graphMorph_func (joinGraph_graphMorph X Y))) Id_func
  // have W: weightprof (category_cat J')  (joinGraph X Y) { refine terminal_weightprof _ _; };
  // compute W;

//   have l' : Œ† M: obj (category_cat J'), Œ† N: graph_Obj A, 
//     weightprof_Arr (subst_cov_weightprof (terminal_weightprof _ _) (joinGraph_graphMorph X Y)) M N ‚Üí 
//     (category_Arr (obj_category_Obj (M ‚àò>o L)) (obj_category_Obj ((graph_Obj_obj N) ‚àò>o F)))
// //    category_Arr (obj_category_Obj (M ‚àò>o L)) (obj_category_Obj (graph_Obj_obj N ‚àò>o (F <‚àò graphMorph_func (joinGraph_graphMorph X Y))))
//   { 
//   refine (Œª M N a, arr_category_Arr (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l) M N a));
//   };
  // have l' : Œ† M: obj (category_cat J'), Œ† N: graph_Obj A, 
  //   weightprof_Arr (subst_cov_weightprof W (joinGraph_graphMorph X Y)) M N ‚Üí 
  //     arr (M ‚àò>o L) (Unit_mod Id_func (F <‚àò graphMorph_func (joinGraph_graphMorph X Y)))  (graph_Obj_obj N)
  // { refine (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l))};

  have extra_arr : 
  (category_Arr (obj_category_Obj (graph_Obj_obj X ‚àò>o F)) (obj_category_Obj (graph_Obj_obj Y ‚àò>o F)))
  // category_Arr (obj_category_Obj (@graph_elim_cov_func_Obj (joinGraph X Y) _ F X ‚àò>o Id_func)) (obj_category_Obj (Terminal_obj ‚àò>o Obj_func (@graph_elim_cov_func_Obj (joinGraph X Y) _ F Y)))
  //arr (@graph_elim_cov_func_Obj (joinGraph X Y) _ F X) (Unit_mod Id_func (Obj_func (@graph_elim_cov_func_Obj (joinGraph X Y) _ F Y))) Terminal_obj
  { refine (arr_category_Arr (graph_elim_cov_func_Arr F (joinGraph_Arr_introNew X Y)));
  };

  have F_dia : diagram (joinGraph X Y) B
  { refine @Struct_diagram (joinGraph X Y) _ (Œª I: graph_Obj (joinGraph X Y), (obj_category_Obj (@graph_elim_cov_func_Obj (joinGraph X Y) _ F I))) 
      (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (joinGraph X Y) _ F M1 N1 a1)) ;        
  };
  have l_cone : Œ† M, cone (obj_category_Obj ((category_Obj_obj M) ‚àò>o L))
      (comp_graphMorph_diagram (joinGraph_graphMorph X Y) 
      /* F_dia */ (@Struct_diagram (joinGraph X Y) _ (Œª I : graph_Obj (joinGraph X Y), (obj_category_Obj (@graph_elim_cov_func_Obj (joinGraph X Y) _ F I))) 
              (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (joinGraph X Y) _ F M1 N1 a1))) )
  { refine Œª M, Struct_cone (Œª N, /* l' */ (Œª M N a, arr_category_Arr (weightprof_elim_transf_cov_Arr (Eval_cov_hom_transf  l) M N a)) M N _); 
  admit; /* TEST */
  };
  have l_Hequa : Œ† M, equalizer /* F_dia */ (@Struct_diagram (joinGraph X Y) _ (Œª I : graph_Obj (joinGraph X Y), (obj_category_Obj (@graph_elim_cov_func_Obj (joinGraph X Y) _ F I))) 
  (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (joinGraph X Y) _ F M1 N1 a1)))
    (l_cone M)
  { refine (Œª M, Hequa A X Y (obj_category_Obj ((category_Obj_obj M) ‚àò>o L))
    /* F_dia */ (@Struct_diagram (joinGraph X Y) _ (Œª I : graph_Obj (joinGraph X Y), (obj_category_Obj (@graph_elim_cov_func_Obj (joinGraph X Y) _ F I))) 
        (Œª M1 N1 a1, arr_category_Arr (@graph_elim_cov_func_Arr (joinGraph X Y) _ F M1 N1 a1)))
    (l_cone M))
  }; 
  refine Struct_iqualizer _ _ _ _
  { refine category_elim_cov_func _ _
    { assume M;
      refine (category_Obj_obj (equalizing_Obj (equalizer_Equalizing (l_Hequa M))));
    }
    { admit;
    };
  }
  { refine category_elim_cov_hom _ ;
  assume M; simplify;
  apply (category_Arr_cov_arr (category_Obj_obj (equalizing_Obj (equalizer_Equalizing (l_Hequa M)))) (category_Obj_obj M ‚àò>o L) (equalizing_Arr (equalizer_Equalizing (l_Hequa M))));
  //category_Arr (equalizing_Obj (equalizer_Equalizing (l_Hequa M))) (obj_category_Obj (category_Obj_obj M ‚àò>o L))
  }
  { refine (Lambda_cov_transf_hom (weightprof_elim_transf _ _ _));
    assume M N _ /* TEST */;
    simplify;
    type (category_Arr_cov_arr (category_Obj_obj (equalizing_Obj (equalizer_Equalizing (l_Hequa M))))  ((graph_Obj_obj N) ‚àò>o F) (@cone_Arr (joinGraph X Y) _ _ _ (equalizing_Cone (equalizer_Equalizing (l_Hequa M))) N));
    //category_Arr (equalizing_Obj (equalizer_Equalizing (l_Hequa (obj_category_Obj M)))) (diagram_Obj (Struct_diagram (Œª I, obj_category_Obj (graph_elim_cov_func_Obj F I)) (Œª M1 N1 a1, arr_category_Arr (graph_elim_cov_func_Arr F a1))) N)
    refine ( (category_Arr_cov_arr _  _ (@cone_Arr (joinGraph X Y) _ _ _ (equalizing_Cone (equalizer_Equalizing (l_Hequa M))) N))
    '‚àòa ((Id_func)_'‚àò> Func_cov_hom F (Obj_func (graph_Obj_obj N))) );
  }
  { assume e;
   simplify;
   type @func;
     //proofterm;
     admit;

  };
end; //abort;



symbol example_liset_iqualizer ‚âî lemma_data_equalizer_iqualizer 
(@liset_equalizer)
(diagram_func joinconstanttwobinarydiagram)
(terminal_weightprof _ _)
(Lambda_cov_transf_hom (cone_transf producttwobinary_Cone)) ;

//forgot this rule, had to reverse engineer from the stuck computation to discover it
rule arr_category_Arr ($a '‚àòa ( (_) _'‚àò> Func_cov_hom $F $Z)) ‚Ü™ arr_category_Arr $a;

compute (equalizing_Obj (equalizer_Equalizing example_liset_equalizer ));
compute ((category_Obj_obj One) ‚àò>o (iqualizer_Func example_liset_iqualizer));
assert ‚ä¢ ((category_Obj_obj One) ‚àò>o (iqualizer_Func example_liset_iqualizer))
‚â° @category_Obj_obj liset (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1) ‚∏¨ ‚ñ°));
assert ‚ä¢ obj_category_Obj ((category_Obj_obj One) ‚àò>o (iqualizer_Func example_liset_iqualizer))
‚â° (equalizing_Obj (equalizer_Equalizing example_liset_equalizer ));


symbol example_liset_iproduct ‚âî lemma_data_product_iproduct
(@liset_product)
(diagram_func optionternarytwobinarydiagram)
(terminal_weightprof _ _)
(Lambda_cov_transf_hom (cone_transf producttwobinary_Cone)) ;

compute obj_category_Obj ((category_Obj_obj One) ‚àò>o (iproduct_Func example_liset_iproduct));
assert ‚ä¢ obj_category_Obj ((category_Obj_obj One) ‚àò>o (iproduct_Func example_liset_iproduct))
‚â° (producing_Obj (product_Producing example_liset_product ));
assert ‚ä¢ obj_category_Obj ((category_Obj_obj One) ‚àò>o (iproduct_Func example_liset_iproduct))
‚â° Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)) (Base_natUniv 7) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 9) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 8) ‚∏¨ (Pair_natUniv (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)) (Base_natUniv 7) ‚∏¨ ‚ñ°)))))))))));

symbol example_liset_iterminal ‚âî @lemma_data_terminal_iterminal terminal_category _ (@liset_terminal) ;

 
///////-------

symbol construct_inductively_limit' : Œ† [J': category], Œ† [B: cat], 
(iterminal (category_cat J') B) ‚Üí 
(Œ† A: graph, 
Œ† F: func (graph_cat (optionGraph A)) B, 
Œ† W: weightprof J' (optionGraph A), 
Œ† L: func (category_cat J') B, 
Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func (F <‚àò graphMorph_func (optionGraph_graphMorph A))) 
  ((weightprof_mod W) <<‚àò graphMorph_func (optionGraph_graphMorph A))) Id_func, iproduct F (weightprof_mod W) l) ‚Üí 
(Œ† A: graph, Œ† X: graph_Obj A, Œ† Y: graph_Obj A, 
Œ† F: func (graph_cat (joinGraph X Y)) B, 
Œ† W: weightprof J' (joinGraph X Y), 
Œ† L: func (category_cat J') B, 
Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func (F <‚àò graphMorph_func (joinGraph_graphMorph X Y))) 
  ((weightprof_mod W) <<‚àò graphMorph_func (joinGraph_graphMorph X Y))) Id_func, iqualizer F (weightprof_mod W) l) ‚Üí 
Œ† A: graph, isFiniteGraph A ‚Üí 
œÑ `Œ†_ F: func (graph_cat A) B, 
`Œ†_ W: weightprof J' A, 
ilimit_Set F (weightprof_mod W) ‚âî 
begin
assume J' B Hterminal Hprod Hequa;
refine (rect_isFiniteGraph _ _ _ _ )
{ refine (@lemma_ind_base_iterminal_ilimit' J' B Hterminal)
}
{ refine (@lemma_ind_hypothesis_iproduct_ilimit' J' B Hprod)
}
{ refine (@lemma_ind_hypothesis_iqualizer_ilimit' J' B Hequa)
};
end;

// //MEMO: this possible general alternative is provable, but it cannot be simply linked to the concrete data lemmas
// symbol construct_inductively_limit : Œ† [J': cat], Œ† [B: cat], 
// (iterminal J' B) ‚Üí 
// (Œ† A: graph, 
// Œ† F: func (graph_cat (optionGraph A)) B, 
// Œ† W: mod J' (graph_cat (optionGraph A)), 
// Œ† L: func J' B, 
// Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func (F <‚àò graphMorph_func (optionGraph_graphMorph A))) 
//   (W <<‚àò graphMorph_func (optionGraph_graphMorph A))) Id_func, iproduct F W l) ‚Üí 
// (Œ† A: graph, Œ† X: graph_Obj A, Œ† Y: graph_Obj A, 
// Œ† F: func (graph_cat (joinGraph X Y)) B, 
// Œ† W: mod J' (graph_cat (joinGraph X Y)), 
// Œ† L: func J' B, 
// Œ† l: hom L (Imply_cov_mod (Unit_mod Id_func (F <‚àò graphMorph_func (joinGraph_graphMorph X Y))) 
//   (W <<‚àò graphMorph_func (joinGraph_graphMorph X Y))) Id_func, iqualizer F W l) ‚Üí 
// Œ† A: graph, isFiniteGraph A ‚Üí 
// œÑ `Œ†_ F: func (graph_cat A) B, 
// `Œ†_ W: mod J' (graph_cat A), 
// ilimit_Set F W ‚âî 
// begin
// assume J' B Hterminal Hprod Hequa;
// refine (rect_isFiniteGraph _ _ _ _ )
// { refine (@lemma_ind_base_iterminal_ilimit J' B Hterminal)
// }
// { refine (@lemma_ind_hypothesis_iproduct_ilimit J' B Hprod)
// }
// { refine (@lemma_ind_hypothesis_iqualizer_ilimit J' B Hequa)
// };
// end;

symbol construct_inductively_limit'_instance : Œ† [J' B : category ], 
(terminal B) ‚Üí
(Œ† A: graph, Œ† L: category_Obj B, 
  Œ† F: diagram (optionGraph A) B, 
  Œ† t: cone L (comp_graphMorph_diagram (optionGraph_graphMorph A) F), 
  product F t) ‚Üí
(Œ† A: graph, Œ† X: graph_Obj A, Œ† Y: graph_Obj A, Œ† L: category_Obj B, 
  Œ† F: diagram (joinGraph X Y) B, 
  Œ† t: cone L (comp_graphMorph_diagram (joinGraph_graphMorph X Y) F), 
  equalizer F t) ‚Üí
Œ† A: graph, isFiniteGraph A ‚Üí 
œÑ `Œ†_ F: func (graph_cat A) (category_cat B), 
`Œ†_ W: weightprof J' A, 
ilimit_Set F (weightprof_mod W) ‚âî 
begin 
assume J' B Hterminal Hprod Hequa;
refine @construct_inductively_limit' J' (category_cat B)
(@lemma_data_terminal_iterminal J' B Hterminal)
(@lemma_data_product_iproduct J' B Hprod)
 (@lemma_data_equalizer_iqualizer J' B Hequa);
end;

symbol construct_inductively_limit'_instance_liset (A: graph) (A_isf : isFiniteGraph A) (F: diagram A liset) ‚âî @construct_inductively_limit'_instance (terminal_category) _ @liset_terminal @liset_product @liset_equalizer A A_isf (diagram_func F) (terminal_weightprof terminal_category A);

// limit cone apex object
compute obj_category_Obj ((category_Obj_obj One) ‚àò>o (sigma_Fst (construct_inductively_limit'_instance_liset _ onearrowthreeverticesgraph_isf oneconstanttwobinaryoneternarydiagram)));

//Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 13)) (Base_natUniv 21)) (Base_natUniv 31) ‚∏¨ (Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 13)) (Base_natUniv 22)) (Base_natUniv 31) ‚∏¨ (Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 12)) (Base_natUniv 21)) (Base_natUniv 31) ‚∏¨ (Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 12)) (Base_natUniv 22)) (Base_natUniv 31) ‚∏¨ (Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 11)) (Base_natUniv 21)) (Base_natUniv 31) ‚∏¨ (Pair_natUniv (Pair_natUniv (Pair_natUniv (Base_natUniv 0) (Base_natUniv 11)) (Base_natUniv 22)) (Base_natUniv 31) ‚∏¨ ‚ñ°)))))


//limit cone sides arrows
compute arr_category_Arr ((Eval_cov_hom_transf ((sigma_Snd (construct_inductively_limit'_instance_liset _ onearrowthreeverticesgraph_isf oneconstanttwobinaryoneternarydiagram))‚ÇÅ ))  ‚àòa' ( (@weightprof_Arr_arr _ _ _ (category_Obj_obj One) (graph_Obj_obj None) One))  );
// Œª x, natUniv_snd x
compute arr_category_Arr ((Eval_cov_hom_transf ((sigma_Snd (construct_inductively_limit'_instance_liset _ onearrowthreeverticesgraph_isf oneconstanttwobinaryoneternarydiagram))‚ÇÅ ))  ‚àòa' ( (@weightprof_Arr_arr _ _ _ (category_Obj_obj One) (graph_Obj_obj (Some (Some None))) One))  );
// Œª x, natUniv_snd (natUniv_fst (natUniv_fst x))

assert ‚ä¢ arr_category_Arr ((Eval_cov_hom_transf ((sigma_Snd (construct_inductively_limit'_instance_liset _ onearrowthreeverticesgraph_isf oneconstanttwobinaryoneternarydiagram))‚ÇÅ ))  ‚àòa' ( (@weightprof_Arr_arr _ _ _ (category_Obj_obj One) (graph_Obj_obj (Some (Some None))) One))  )
‚â° Œª x, natUniv_snd (natUniv_fst (natUniv_fst x)) ;


////////////--------

///OUTPUT reverse engineered
/* category_Obj_obj (if (natUniv_eq (Base_natUniv 1) 
(arr_category_Arr ( category_Arr_cov_arr 
(category_Obj_obj (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1) ‚∏¨ ‚ñ°)))))
(category_Obj_obj (Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°)))
 natUniv_snd 
 '‚àòa (Id_func _'‚àò> Func_cov_hom 
 (diagram_func (Struct_diagram (Œª _, Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°)) (Œª _ _ a, rect_empty a))) 
 (Obj_func (graph_Obj_obj (Struct_sub (Base_natUniv 2) top)))))
 (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2)))) 
(Pair_natUniv (Base_natUniv 2) (Base_natUniv 2) ‚∏¨ if (natUniv_eq (Base_natUniv 1) (arr_category_Arr (category_Arr_cov_arr (category_Obj_obj (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1) ‚∏¨ ‚ñ°))))) (category_Obj_obj (Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°))) natUniv_snd '‚àòa (Id_func _'‚àò> Func_cov_hom (diagram_func (Struct_diagram (Œª _, Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°)) (Œª _ _ a, rect_empty a))) (Obj_func (graph_Obj_obj (Struct_sub (Base_natUniv 2) top))))) (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1)))) (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ if (natUniv_eq (Base_natUniv 1) (arr_category_Arr (category_Arr_cov_arr (category_Obj_obj (Pair_natUniv (Base_natUniv 2) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 2) (Base_natUniv 1) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 2) ‚∏¨ (Pair_natUniv (Base_natUniv 1) (Base_natUniv 1) ‚∏¨ ‚ñ°))))) (category_Obj_obj (Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°))) natUniv_snd '‚àòa (Id_func _'‚àò> Func_cov_hom (diagram_func (Struct_diagram (Œª _, Base_natUniv 2 ‚∏¨ (Base_natUniv 1 ‚∏¨ ‚ñ°)) (Œª _ _ a, rect_empty a))) ...
 */

