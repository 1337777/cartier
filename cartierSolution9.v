(** # #
#+TITLE: cartierSolution9.v

Proph

https://gitee.com/OOO1337777/cartier/blob/master/cartierSolution9.v

solves half of some question of CARTIER which is how to program « parametrization modos » ( "parametrized form" , "dependent type" , "fibration with internal products" ) ...

SHORT ::

  The ends is to program the « form-morphisms » parametrized-over the « parametrizator-arrows » ( "fibration" ) , which are generated by some « generating » parametrization-functor , such that this programming enables the computational-logical introductions-eliminations constructors and the cut-elimination/admissibility lemma when in the presence of the grammatical « product/pi-objects » or the grammatical « substitution-objects » or the grammatical « colimit/sum/sigma/viewingfunctor-objects » .

  Commonly , the "lambda calculus" has the « cancellation » computation [  ( ( application s ) <o ( abstraction f ) )  :=  substitution ( f , s )  ] , where [ f ] is some function and [ s ] is some element ; but now in contrast the input function [ f ] (transformation function from representable/generator functor into the product-object/functor) shall be viewed as parametrized-over the given/fixed context-projection function (which defines the product-object) whose input section [ s ] is some now-function which parametrizes its corresponding application function [ application s ] and also parametrizes the output function [ substitution ( f , s ) ] of the substitution operation .  In other words , given any grammatical form-morphism [ f ] of [  |-  ( E ~> F )  ] parametrized-over the parametrizator-arrow ( "span" ) [  project <o> subst  ] , whose sensible-decoding is some « formatted » function [  project* E  |-  subst* F  ] across the « formats » ( "pullbacks" ) from [  project* E  ] to [  subst* F  ] parametrized-over the (elements of the) parameter (functor) [ P ] , oneself shall :
  (1) introduce some grammatical product/pi-object ( « pi-substitution » ) with ( « pairing » ) morphism [  |-  ( E ~> PI_project SUBST_subst F )  ]  ,
  (2) or introduce some grammatical substitution-object with ( « remembering » ) morphism [  |-  ( E ~> SUBST_subst F )  ] for the instances when [ project ] is identity ,
  (3) and do such coherently/continuously for the viewing-data/topology sense-decodings which are internalized via the elimination of the (parametrized-and-modified) grammatical colimiting/sum/sigma/viewingfunctor objects ( parametrized-and-modified rephrasing of « each functor is the sum/colimit of its elements » ) : [  X ; (p : P X) ; (e : E X (project p))  |-  F X (subst p)  ] .

  Memo that this polymorph formulation of pi/substitution precartesian-projection ( "lifting" ) morphisms has post-composition by any accumulator-morphism built-in grammatically , therefore precartesianness infers cartesianness ( II.8.1.7 ) . Also memo that this polymorph formulation of the pi-substitution objects has pre-substitution by any accumulator-arrow built-in grammatically , therefore this infers the commutation of formatting/substitution along product : [  t* PI_p SUBST_s  (grammatically via parametrizator)  <->  PI_p SUBST_(t o> s)  (grammatically via object)  ] .

  Memo that any parametrizator-arrow ( "span" ) [ l <o> r ] may be viewed as some function [ r ] whose domain has been reindexed by the function [ l ] , and the composition of two parametrizator-arrows ( "spans" ) is similar as some « polymorph pullback » ; therefore the grammatical cut-elimination/admissibility for such parametrizator-arrows is in fact similar as some « polymorph-pullback-elimination/admissibility » which says that the pullback process among parametrizator-arrows shall be structured/grammatical and not-merely exist in the sense .

  Moreover memo that the form-morphisms parametrized-over the parametrizator-arrows are defined « mutually inductively » with the parametrizator-arrows , which says that , in adddition of « projectifying » ( "lifing" as identity ) from some parametrizator-arrow upto some pi/substitution-projection morphism , then oneself may do « formatting » ( "context extension" by any form-morphism , beyond the common "context extension" by own lifting ) from some form-morphism downto some parametrizator-arrow . Regardless , « sensibly-"discrete" » generating parametrization-functor would be simpler because then only « nested-mutual induction » is required by the non-necessity of this formatting constructor ( "context extension" by any form-morphism ) . At the other extreme , « full » generating parametrization-functor would be simpler because then any element of some parameter-index (functor) has some fixed-chosen extension as polyelement (transformation) .

  In summary , the final expressivity shall allow these two things ( II.8.5.5 ) : (1) mutual induction of form-morphisms with parametrizator-arrows via the presence of the « formatting » constructor , (2) programming locally after « non-empty global contexts » . For (1) , therefore some grammatical pullback-elimination/admissibility for the form-morphisms shall also be necessary , in particular the "fibre-completeness" of the generating parametrization-functor shall be necessary . For (2) , the mathematician counter-part of this engineer-programmer "convenience" is named « localization of fibration at some object of the base » . Regardless , everything can always be compiled back to the empty global context ( II.8.5.9 ) ... 

  Finally , memo that some finiteness properties such as finite-compactness or finite-dimensionality or finite-generated are assumed ; and eventually for the product/pi-objects , this may be generalized in the style of the « compacted-point » technique ( "compact-open topology for the compactly-continuous mappings , which gives compactly-uniform convergence" ( II.7.4.10 )  ... « compacted-parameters compacted-arguments viewing-data for the compacted-viewing-continuous morphisms » ? ) .


E ----------------------- f ---------------------> F
|                                                  |
. PI_project SUBST_subst F ---- application _ ---> .
|  |                                               |
.  |                                               .
|  v                                               |
v ------- section ------->                         v
E_ <----- project ------- P ------- subst -------> F_


#+BEGIN_SRC coq :exports both :results silent # # **)

(** # #
#+END_SRC

Voila.
# # **)
